<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Divyansh Goyal">
<meta name="dcterms.date" content="2024-11-01">
<meta name="description" content="A summary of my project for Google Summer of Code - 2024">

<title>GSoC ’24: Adding functionalities to medical imaging visualizations – JuliaHealth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../assets/favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-65fd452e27565dcd78ad8c8152a052d5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">JuliaHealth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../JuliaHealthBlog/index.html"> 
<span class="menu-text">Blogs</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#hello-everyone" id="toc-hello-everyone" class="nav-link active" data-scroll-target="#hello-everyone">Hello Everyone! 👋</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#what-is-medeye3d.jl" id="toc-what-is-medeye3d.jl" class="nav-link" data-scroll-target="#what-is-medeye3d.jl">What is MedEye3d.jl?</a></li>
  <li><a href="#what-features-does-this-project-encompass" id="toc-what-features-does-this-project-encompass" class="nav-link" data-scroll-target="#what-features-does-this-project-encompass">What features does this project encompass?</a></li>
  </ul></li>
  <li><a href="#project-goals" id="toc-project-goals" class="nav-link" data-scroll-target="#project-goals">Project Goals</a></li>
  <li><a href="#tasks" id="toc-tasks" class="nav-link" data-scroll-target="#tasks">Tasks</a>
  <ul class="collapse">
  <li><a href="#migration-of-package-from-rocket-to-julias-base.channel" id="toc-migration-of-package-from-rocket-to-julias-base.channel" class="nav-link" data-scroll-target="#migration-of-package-from-rocket-to-julias-base.channel">1. Migration of package from Rocket to Julia’s Base.Channel</a></li>
  <li><a href="#implementation-of-high-level-functions-with-simplified-basic-usage" id="toc-implementation-of-high-level-functions-with-simplified-basic-usage" class="nav-link" data-scroll-target="#implementation-of-high-level-functions-with-simplified-basic-usage">2. Implementation of high level functions with simplified basic usage</a></li>
  <li><a href="#improved-precompilation-with-decreased-outputs-to-reduce-start-time" id="toc-improved-precompilation-with-decreased-outputs-to-reduce-start-time" class="nav-link" data-scroll-target="#improved-precompilation-with-decreased-outputs-to-reduce-start-time">3. Improved precompilation with decreased outputs to reduce start time</a></li>
  <li><a href="#automatic-windowing-for-most-common-mri-and-pet-modalities" id="toc-automatic-windowing-for-most-common-mri-and-pet-modalities" class="nav-link" data-scroll-target="#automatic-windowing-for-most-common-mri-and-pet-modalities">4. Automatic windowing for most common MRI and PET modalities</a></li>
  <li><a href="#adding-support-for-multi-image-viewing-with-crosshair-marker-for-image-registration" id="toc-adding-support-for-multi-image-viewing-with-crosshair-marker-for-image-registration" class="nav-link" data-scroll-target="#adding-support-for-multi-image-viewing-with-crosshair-marker-for-image-registration">5. Adding support for multi-image viewing with crosshair marker for image registration</a></li>
  <li><a href="#adding-support-for-the-display-of-supervoxels-sv-with-borders-within-the-image-slices-to-better-understand-anatomical-regions-within-slices" id="toc-adding-support-for-the-display-of-supervoxels-sv-with-borders-within-the-image-slices-to-better-understand-anatomical-regions-within-slices" class="nav-link" data-scroll-target="#adding-support-for-the-display-of-supervoxels-sv-with-borders-within-the-image-slices-to-better-understand-anatomical-regions-within-slices">6. Adding support for the display of SuperVoxels sv with borders within the image slices to better understand anatomical regions within slices</a></li>
  </ul></li>
  <li><a href="#contributions-beyond-coding" id="toc-contributions-beyond-coding" class="nav-link" data-scroll-target="#contributions-beyond-coding">Contributions Beyond Coding</a>
  <ul class="collapse">
  <li><a href="#mentoring-and-guidance" id="toc-mentoring-and-guidance" class="nav-link" data-scroll-target="#mentoring-and-guidance">1. Mentoring and Guidance</a></li>
  <li><a href="#package-documentation-and-community-contribution" id="toc-package-documentation-and-community-contribution" class="nav-link" data-scroll-target="#package-documentation-and-community-contribution">2. Package Documentation and Community Contribution</a></li>
  <li><a href="#multirepo-management-and-collaboration" id="toc-multirepo-management-and-collaboration" class="nav-link" data-scroll-target="#multirepo-management-and-collaboration">3. Multirepo Management and Collaboration</a></li>
  </ul></li>
  <li><a href="#conclusions-and-future-development" id="toc-conclusions-and-future-development" class="nav-link" data-scroll-target="#conclusions-and-future-development">Conclusions and Future Development</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements 🙇‍♂️</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">GSoC ’24: Adding functionalities to medical imaging visualizations</h1>
  <div class="quarto-categories">
    <div class="quarto-category">gsoc</div>
    <div class="quarto-category">openGl</div>
    <div class="quarto-category">imaging</div>
    <div class="quarto-category">neuro</div>
  </div>
  </div>

<div>
  <div class="description">
    A summary of my project for Google Summer of Code - 2024
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Divyansh Goyal </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 1, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="hello-everyone" class="level1">
<h1>Hello Everyone! 👋</h1>
<p>I am Divyansh, an undergraduate student from Guru Gobind Singh Indraprastha university, majoring in Artificial Intelligence and Machine Learning. Stumbling upon projects under the Juliahealth sub-ecosystem of medical imaging packages, the intricacies of imaging modalities and file formats, reflected in their relevant project counterparts, captured my interest. Working with standards such as NIfTI (Neuroimaging Informatics Technology Initiative) and DICOM (Digital Imaging and Communications in Medicine) with MedImages.jl, I became interested in the visualization routines of such imaging datasets and their integration within the segmentation pipelines for modern medical-imaging analysis.</p>
<p>In this post, I’d like to summarize what I did this summer and everything I learned along the way, contributing to MedEye3d.jl medical imaging visualizer under GSOC-2024!</p>
<blockquote class="blockquote">
<p>If you want to learn more about me, you can connect with me on <a href="https://www.linkedin.com/in/divyansh-goyal-34654b200/"><strong>LinkedIn</strong></a> and follow me on <a href="https://github.com/divital-coder"><strong>GitHub</strong></a></p>
</blockquote>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<section id="what-is-medeye3d.jl" class="level2">
<h2 class="anchored" data-anchor-id="what-is-medeye3d.jl">What is MedEye3d.jl?</h2>
<p><a href="https::/github.com/Juliahealth/MedEye3d.jl">MedEye3D.jl</a> is a package under the Julia language ecosystem designed to facilitate the visualization and annotation of medical images. Tailored specifically for medical applications, it offers a range of functionalities to enhance the interpretation and analysis of medical images. MedEye3D aims to provide an essential tool for 3D medical imaging workflow within Julia. The underlying combination of <a href="https://github.com/ReactiveBayes/Rocket.jl">Rocket.jl</a> and <a href="https://github.com/JuliaGL/ModernGL.jl">ModernGL.jl</a> ensures the high-performance robust visualizations that the package has to offer.</p>
<p>MedEye3d.jl is open-source and comes with an intuitive user interface (To learn more about MedEye3d, you can read the paper introducing it <a href="https://doi.org/10.26348/znwwsi.25.57">here</a> <span class="citation" data-cites="Mitura2021"><a href="#ref-Mitura2021" role="doc-biblioref">[1]</a></span>).</p>
</section>
<section id="what-features-does-this-project-encompass" class="level2">
<h2 class="anchored" data-anchor-id="what-features-does-this-project-encompass">What features does this project encompass?</h2>
<p>This project covers implementation of several tasks that will enable the establishment of additional important functionalities within the MedEye3D package, facilitating enhancements within the visualization’s windowing for MRI and PET data, support for super voxels (sv), improved load times, high-level functionality implementation and robust viewing for multiple images.</p>
</section>
</section>
<section id="project-goals" class="level1">
<h1>Project Goals</h1>
<p>The goals outlined by Dr.&nbsp;Jakub Mitura (my project mentor) and I, beginning of this summer were:</p>
<ol type="1">
<li><p>Migration of package reliance from <a href="https://github.com/reactivebayes/Rocket.jl">Rocket.jl</a> to base Julia channel and macros: The first decision that was made was to fix the issue of screen tearing and flicker, resulting from the Rocket.jl’s actor-subscription mechanism present at the core of MedEye3d.jl’s event-driven programming. Here, Julia’s threadsafe and asynchronous <a href="https://docs.julialang.org/en/v1/manual/asynchronous-programming/">channels</a> provided a way to introduce reactive programming and state management within MedEye3d without the tradeoffs resulting from external packages such as Rocket</p></li>
<li><p>Implementation of high level functions with simplified basic usage: Prior to this, MedEye3d involved initialization of data, texture specifications and text display for a final visualization. To reduce complexity, methods to abstract such chores were devised and implemented which resulted in the exposure of functions for loading images, accessing display data and modification of display data. This also encompassed the loading of images via <a href="https://github.com/juliahealth/MedImages.jl">MedImages.jl</a> which required prior work for the integration of C++ <a href="https://github.com/InsightSoftwareConsortium/ITK">ITK</a> backend for image I/O.</p></li>
<li><p>Improved precompilation with decreased outputs to reduce start time</p></li>
<li><p>Automatic windowing for most common MRI and PET modalities: This task is a step in the direction of maintaining consistent visualizations across MRI and PET’s most common modalities, to mimic images similar to what is displayed within <a href="https://www.slicer.org/">3dSlicer</a> for the same.</p></li>
<li><p>Adding support for multi-image viewing with crosshair marker for image registration</p></li>
<li><p>Adding support for the display of <a href="https://doi.org/10.1016/j.cagd.2022.102080">SuperVoxels</a> sv with borders within the image slices to better understand anatomical regions within slices: Supervoxels, described either through indicator masks or meshes, encapsulate regions of interest with distinct image characteristics.</p></li>
</ol>
<p>Additionally, we had a few stretch goals which are going to be a work in progress:</p>
<ol type="1">
<li><p>Visualization of structures by 3D rendering using OpenGL,</p></li>
<li><p>Support for MedVoxelHD visualization by voxel-based Hausdorff distance computation.</p></li>
<li><p>Support for OSX users</p></li>
</ol>
</section>
<section id="tasks" class="level1">
<h1>Tasks</h1>
<section id="migration-of-package-from-rocket-to-julias-base.channel" class="level2">
<h2 class="anchored" data-anchor-id="migration-of-package-from-rocket-to-julias-base.channel">1. Migration of package from Rocket to Julia’s Base.Channel</h2>
<p>Initially, there was significant screen-tearing evident from the pixelated display of the rendered text and main image which, furthermore exhibited flickering upon scrolling through the slices in the relevant displayed image’s planar views i.e (Transversal, Coronal and Saggital). Troubleshooting along the way, we narrowed down the issue within the Rocket’s actor-subscription mechanism and decided to integrate Julia’s Base.Channel within <a href="https://github.com/Juliahealth/MedEye3d.jl">MedEye3d.jl</a> for handling the event and state management routine. Julia has asynchronous, threadsafe <a href="https://docs.julialang.org/en/v1/manual/asynchronous-programming/#Communicating-with-Channels">channels</a> which facilitate in asynchronous programming with the help of a producer-consumer mechanism. An example usage of Base.Channel is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">consumer</span>(channel<span class="op">::</span><span class="dt">Base.Channel</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(<span class="cn">true</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    channelData<span class="op">::</span><span class="dt">String </span><span class="op">=</span> <span class="fu">take!</span>(channel)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">println</span>(<span class="st">"Channel got "</span> <span class="op">*</span> channelData)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>newChannel <span class="op">=</span> <span class="bu">Base</span>.<span class="fu">Channel</span>(<span class="fl">100</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="pp">@async</span> <span class="fu">consumer</span>(newChannel)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">put!</span>(newChannel, <span class="st">"apples"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Julia’s multiple dispatch made for the architectural setup of MedEye3d, facilitated fixing the issue of screen tearing. Below is how the <code>on_next!</code> function, invokes different reactive components based on the types of arguments it is dealing with.</p>
<blockquote class="blockquote">
<p>Dump data in channel -&gt; fetch data from the channel in an event loop -&gt; invoke <code>on_next!(state, channelData)</code> -&gt; invoke relevant functionality based on the type of arguments passed</p>
</blockquote>
<p><img src="./multiple_dispatch_code.png" class="img-fluid"></p>
<p>The end result was a visualizer with a seamless display of a CT image without any pixelating artifacts.</p>
<p><img src="./fixed_screen_tear.png" class="img-fluid"></p>
</section>
<section id="implementation-of-high-level-functions-with-simplified-basic-usage" class="level2">
<h2 class="anchored" data-anchor-id="implementation-of-high-level-functions-with-simplified-basic-usage">2. Implementation of high level functions with simplified basic usage</h2>
<p>Implementing a bare-bones image visualization required a lot of function calls and definitions, in order to execute the following phases:</p>
<ol type="1">
<li><p>Rendering an image-plane with OpenGL</p></li>
<li><p>Loading data slices from the image</p></li>
<li><p>Creating texture specifications for modalities</p></li>
<li><p>Producing the final segmentation display</p></li>
</ol>
<p>In order to simplify basic usage, high-level abstractions were put in place with the help of <a href="https://github.com/MedImages.jl">MedImages.jl</a> (under ongoing development) library to load images in the form of MedImage objects to formulate a single display function for the user. Further simplifications were made to accommodate options for the user to manipulate the imaging data that is displayed currently in the visualizer i.e retrieval of voxel arrays and their modification. Taking this in mind, the following relevant functions were exposed:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>MedEye3d.SegmentationDisplay.<span class="fu">displayImage</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>MedEye3d.DisplayDataManag.<span class="fu">getDisplayedData</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>MedEye3d.DisplayDataManag.<span class="fu">setDisplayedData</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Putting all of the above functions to use together, we can launch the visualizer, retrieve the displayed voxel data and modify it to our liking. A sample script to achieve the former, is highlighted below:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">MedEye3d</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ctNiftiImage <span class="op">=</span> <span class="st">"/home/hurtbadly/Downloads/ct_soft_study.nii.gz"</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>medEyeStruct <span class="op">=</span> MedEye3d.SegmentationDisplay.<span class="fu">displayImage</span>(ctNiftiImage)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>displayData <span class="op">=</span> MedEye3d.DisplayDataManag.<span class="fu">getDisplayedData</span>(medEyeStruct, [<span class="fu">Int32</span>(<span class="fl">1</span>), <span class="fu">Int32</span>(<span class="fl">2</span>)]) <span class="co">#passing the active texture number</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># We need to check if the return type of the displayData is a single Array{Float32,3} or a vector{Array{Float32,3}}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Now in this case we are setting Gaussian noise over the manualModif Texture voxel layer, and the manualModif texture defaults to 2 for active number</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>displayData[<span class="fl">2</span>][<span class="op">:</span>, <span class="op">:</span>, <span class="op">:</span>] <span class="op">=</span> <span class="fu">randn</span>(<span class="dt">Float32</span>, <span class="fu">size</span>(displayData[<span class="fl">2</span>]))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>MedEye3d.DisplayDataManag.<span class="fu">setDisplayedData</span>(medEyeStruct, displayData)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The result of this <a href="https://www.sfu.ca/sonic-studio-webdav/handbook/Gaussian_Noise.html">Gaussian noise</a> within the annotation layer, made for an outcome like the following:</p>
<p><img src="./gaussian_noise_annotation.png" class="img-fluid"></p>
</section>
<section id="improved-precompilation-with-decreased-outputs-to-reduce-start-time" class="level2">
<h2 class="anchored" data-anchor-id="improved-precompilation-with-decreased-outputs-to-reduce-start-time">3. Improved precompilation with decreased outputs to reduce start time</h2>
<p>Previously, the package’s precompilation was failing in Julia v1.9 and v1.10 due to pattern matching errors arising after the usage of match macros from the <a href="https://github.com/JuliaServices/Match.jl">Match.jl</a> pkg in MedEye3d’s keymapping workflow between GLFW callbacks from mouse and keyboard. The relevant equivalent native conditional (if-else) statements, resolved the issue and facilitated in successful precompilation of the package. Further, only following minimal outputs were produced during precompilation:</p>
<p><img src="./precompilation_outputs.png" class="img-fluid"></p>
<p>Changes highlighted within the following pull-request:</p>
<p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/12">https://github.com/JuliaHealth/MedEye3d.jl/pull/12</a></p>
</section>
<section id="automatic-windowing-for-most-common-mri-and-pet-modalities" class="level2">
<h2 class="anchored" data-anchor-id="automatic-windowing-for-most-common-mri-and-pet-modalities">4. Automatic <a href="https://youtu.be/HaL-G43kwKA">windowing</a> for most common MRI and PET modalities</h2>
<p>Windowing is a crucial aspect of medical imaging, particularly in MRI (Magnetic Resonance Imaging) and PET (Positron Emission Tomography) modalities. It enables radiologists to enhance the contrast of images, highlighting specific features and improving the overall diagnostic accuracy. Windowing involves controlling the display range of pixel values to optimize the contrast between different tissues or structures. The display range is defined by two values: the minimum (min) and maximum (max) values that contribute to the final range of pixels that are displayed. By adjusting these values, radiologists can enhance or suppress specific features in the image, facilitating a more accurate diagnosis.</p>
<p>The <code>setTextureWindow</code> function utilizes a set of predefined keymap controls to simplify the windowing process. The F1-F7 keys are designated for controlling windowing in MRI and PET modalities. The keymap controls are as follows:</p>
<ul>
<li><p>F1: Display wide window for bone (CT) or increase minimum value for PET</p></li>
<li><p>F2: Display window for soft tissues (CT) or increase minimum value for PET</p></li>
<li><p>F3: Display wide window for lung viewing (CT) or increase minimum value for PET</p></li>
<li><p>F4: Decrease minimum value for display</p></li>
<li><p>F5: Increase minimum value for display</p></li>
<li><p>F6: Decrease maximum value for display</p></li>
<li><p>F7: Increase maximum value for display</p></li>
</ul>
<p>Implementation of <code>setTextureWindow</code> Function</p>
<p>The <code>setTextureWindow</code> function is designed to update the texture window settings based on the input keymap control. The function takes three arguments:</p>
<ul>
<li><code>activeTextur</code>: The current texture specification</li>
<li><code>stateObject</code>: The state data fields</li>
<li><code>windowControlStruct</code>: The window control structure containing the letter code for the keymap control</li>
</ul>
<p>The function performs the following steps:</p>
<ol type="1">
<li>Checks the letter code of the keymap control and updates the minimum and maximum values of the texture specification accordingly.</li>
<li>Updates the uniforms for the texture specification using the <code>controlMinMaxUniformVals</code> function.</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">setTextureWindow</span>(activeTextur<span class="op">::</span><span class="dt">TextureSpec</span>, stateObject<span class="op">::</span><span class="dt">StateDataFields</span>, windowControlStruct<span class="op">::</span><span class="dt">WindowControlStruct</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    activeTexturName <span class="op">=</span> activeTextur.name</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    displayRange <span class="op">=</span> activeTextur.minAndMaxValue[<span class="fl">2</span>] <span class="op">-</span> activeTextur.minAndMaxValue[<span class="fl">1</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    activeTexturStudyType <span class="op">=</span> activeTextur.studyType</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F1"</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> activeTexturStudyType <span class="op">==</span> <span class="st">"CT"</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">#Bone windowing in CT</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue <span class="op">=</span> <span class="fu">Float32</span>.([<span class="fl">400</span>, <span class="fl">1000</span>])</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> activeTexturStudyType <span class="op">==</span> <span class="st">"PET"</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue[<span class="fl">1</span>] <span class="op">+=</span> <span class="fl">0.10</span> <span class="op">*</span> displayRange <span class="co">#windowing for pet, in the case of PET simply increase the minimum by 20% , doing the same in f1,f2 and f3</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F2"</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> activeTexturStudyType <span class="op">==</span> <span class="st">"CT"</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue <span class="op">=</span> <span class="fu">Float32</span>.([<span class="op">-</span><span class="fl">40</span>, <span class="fl">350</span>])</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> activeTexturStudyType <span class="op">==</span> <span class="st">"PET"</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue[<span class="fl">1</span>] <span class="op">+=</span> <span class="fl">0.10</span> <span class="op">*</span> displayRange</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F3"</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> activeTexturStudyType <span class="op">==</span> <span class="st">"CT"</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue <span class="op">=</span> <span class="fu">Float32</span>.([<span class="op">-</span><span class="fl">426</span>, <span class="fl">1000</span>])</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> activeTexturStudyType <span class="op">==</span> <span class="st">"PET"</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            activeTextur.minAndMaxValue[<span class="fl">1</span>] <span class="op">+=</span> <span class="fl">0.10</span> <span class="op">*</span> displayRange</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F4"</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        activeTextur.minAndMaxValue[<span class="fl">1</span>] <span class="op">-=</span> <span class="fl">0.20</span> <span class="op">*</span> displayRange</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F5"</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        activeTextur.minAndMaxValue[<span class="fl">1</span>] <span class="op">+=</span> <span class="fl">0.20</span> <span class="op">*</span> displayRange</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F6"</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        activeTextur.minAndMaxValue[<span class="fl">2</span>] <span class="op">-=</span> <span class="fl">0.20</span> <span class="op">*</span> displayRange</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F7"</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        activeTextur.minAndMaxValue[<span class="fl">2</span>] <span class="op">+=</span> <span class="fl">0.20</span> <span class="op">*</span> displayRange</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F8"</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        activeTextur.uniforms.maskContribution <span class="op">-=</span> <span class="fl">0.10</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> windowControlStruct.letterCode <span class="op">==</span> <span class="st">"F9"</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        activeTextur.uniforms.maskContribution <span class="op">+=</span> <span class="fl">0.10</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    stateObject.mainForDisplayObjects.listOfTextSpecifications <span class="op">=</span> <span class="fu">map</span>(texture <span class="op">-&gt;</span> texture.name <span class="op">==</span> activeTexturName ? activeTextur <span class="op">:</span> texture, stateObject.mainForDisplayObjects.listOfTextSpecifications)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coontrolMinMaxUniformVals</span>(activeTextur)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<blockquote class="blockquote">
<p>Bone windowing in CT</p>
</blockquote>
<p><img src="./ct_windowing.png" class="img-fluid"></p>
<blockquote class="blockquote">
<p>Bone windowing in PET</p>
</blockquote>
<p><img src="./pet_windowing.png" class="img-fluid"></p>
</section>
<section id="adding-support-for-multi-image-viewing-with-crosshair-marker-for-image-registration" class="level2">
<h2 class="anchored" data-anchor-id="adding-support-for-multi-image-viewing-with-crosshair-marker-for-image-registration">5. Adding support for multi-image viewing with crosshair marker for image registration</h2>
<p>Following the mid-term evaluation, MedEye3d.jl underwent a significant enhancement, whereby a multi-image display capability was implemented through a series of refinements. Specifically, a novel approach was adopted, whereby separate OpenGL <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader">fragment shaders</a> were introduced to concurrently render images on either side of the visualizer, namely the left and right views. Prior to integrating voxel data into the fragment shaders, an initial series of tests involved evaluating individual colors to validate the integrity of the double image display. A screenshot from one of these critical testing phases is presented below: <img src="./multi_fragment_shader.png" class="img-fluid"></p>
<p>The shaders were further manipulated to automatically initialize for each of the images separately. Further, the reactive aspect of the visualizer in multi-image display mode was iterated upon and now, instead of a single state management struct, a vector of states was being passed around, facilitating the user to scroll each of the images separately just by simply hovering their mouse over either of the image, activating its relevant associated state struct.</p>
<p>Down below, is the struct for state that handles all of the things currently related with an image:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@with_kw</span> <span class="kw">mutable struct</span> StateDataFields</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  currentDisplayedSlice<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">1</span> <span class="co"># stores information what slice number we are currently displaying</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  mainForDisplayObjects<span class="op">::</span><span class="dt">forDisplayObjects </span><span class="op">=</span> <span class="fu">forDisplayObjects</span>() <span class="co"># stores objects needed to  display using OpenGL and GLFW</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  onScrollData<span class="op">::</span><span class="dt">FullScrollableDat </span><span class="op">=</span> <span class="fu">FullScrollableDat</span>()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  textureToModifyVec<span class="op">::</span><span class="dt">Vector{TextureSpec} </span><span class="op">=</span> [] <span class="co"># texture that we want currently to modify - if list is empty it means that we do not intend to modify any texture</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  isSliceChanged<span class="op">::</span><span class="dt">Bool </span><span class="op">=</span> <span class="cn">false</span> <span class="co"># set to true when slice is changed set to false when we start interacting with this slice - thanks to this we know that when we start drawing on one slice and change the slice the line would star a new on new slice</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  textDispObj<span class="op">::</span><span class="dt">ForWordsDispStruct </span><span class="op">=</span> <span class="fu">ForWordsDispStruct</span>()<span class="co"># set of objects and constants needed for text diplay</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  currentlyDispDat<span class="op">::</span><span class="dt">SingleSliceDat </span><span class="op">=</span> <span class="fu">SingleSliceDat</span>() <span class="co"># holds the data displayed or in case of scrollable data view for accessing it</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  calcDimsStruct<span class="op">::</span><span class="dt">CalcDimsStruct </span><span class="op">=</span> <span class="fu">CalcDimsStruct</span>()   <span class="co">#data for calculations of necessary constants needed to calculate window size , mouse position ...</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  valueForMasToSet<span class="op">::</span><span class="dt">valueForMasToSetStruct </span><span class="op">=</span> <span class="fu">valueForMasToSetStruct</span>() <span class="co"># value that will be used to set  pixels where we would interact with mouse</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  lastRecordedMousePosition<span class="op">::</span><span class="dt">CartesianIndex{3} </span><span class="op">=</span> <span class="fu">CartesianIndex</span>(<span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>) <span class="co"># last position of the mouse  related to right click - usefull to know onto which slice to change when dimensions of scroll change</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  forUndoVector<span class="op">::</span><span class="dt">AbstractArray </span><span class="op">=</span> [] <span class="co"># holds lambda functions that when invoked will  undo last operations</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  maxLengthOfForUndoVector<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">15</span> <span class="co"># number controls how many step at maximum we can get back</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  fieldKeyboardStruct<span class="op">::</span><span class="dt">KeyboardStruct </span><span class="op">=</span> <span class="fu">KeyboardStruct</span>()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  displayMode<span class="op">::</span><span class="dt">DisplayMode </span><span class="op">=</span> SingleImage</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  imagePosition<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">1</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  switchIndex<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">1</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  mainRectFields<span class="op">::</span><span class="dt">GlShaderAndBufferFields </span><span class="op">=</span> <span class="fu">GlShaderAndBufferFields</span>()</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  crosshairFields<span class="op">::</span><span class="dt">GlShaderAndBufferFields </span><span class="op">=</span> <span class="fu">GlShaderAndBufferFields</span>()</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  textFields<span class="op">::</span><span class="dt">GlShaderAndBufferFields </span><span class="op">=</span> <span class="fu">GlShaderAndBufferFields</span>()</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  spacingsValue<span class="op">::</span><span class="dt">Union{Vector{Tuple{Float64,Float64,Float64}},Tuple{Float64,Float64,Float64}} </span><span class="op">=</span> [(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>)]</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  originValue<span class="op">::</span><span class="dt">Union{Vector{Tuple{Float64,Float64,Float64}},Tuple{Float64,Float64,Float64}} </span><span class="op">=</span> [(<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>)]</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  supervoxelFields<span class="op">::</span><span class="dt">GlShaderAndBufferFields </span><span class="op">=</span> <span class="fu">GlShaderAndBufferFields</span>()</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After the integrity of the fragment shaders was verified in multi-image, voxel data for the images was integrated and further modifications to the high-level functions were made and eventually the following script produced a rather appealing result.</p>
<p>Script for loading the same NIFTI image twice in the visualizer for side-by-side display:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">MedEye3d</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ctNiftiImage <span class="op">=</span> <span class="st">"/home/hurtbadly/Downloads/ct_soft_study.nii.gz"</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>MedEye3d.SegmentationDisplay.<span class="fu">displayImage</span>([[ctNiftiImage],[ctNifitImage]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<blockquote class="blockquote">
<p>Results in :</p>
</blockquote>
<p><img src="./multi_image_ct.png" class="img-fluid"></p>
<p>Crosshair marker for image registration are displayed in the relevant passive image to hightlight the same anatomical regions based on the spatial meta-data of the images i.e spacing, origin and direction. In order to achive the crosshair rendering in the passive image, the following action items were devised:</p>
<ol type="a">
<li><p>Retrieval of GLFW Mouse Callbacks for x and y position of the cursor in window coordinates (0 to window-width) from the active image</p></li>
<li><p>Conversion of these x and y window coordinates into their relevant active image x and y texture coordinates</p></li>
<li><p>Conversion of these texture coordinates into real space point with the help of spatial metadata</p></li>
<li><p>Conversion of the real space point into the texture coordinates of the passive image</p></li>
<li><p>Conversion of the passive image texture coordinates into their relevant OpenGL coordinate system values (-1 to 1)</p></li>
<li><p>Rendering of crosshair on OpenGL coordinate in passive image</p></li>
</ol>
<p>Conversion between different coordinate systems and accounting for the image’s spatial metadata during calculating proved to be challenging at first, but with multiple revisions, a final solution was achieved with seemingly no noticeable amount of lag or delay. One such frame of [CT] images with crosshair display in multi-image is depicted below:</p>
<p><img src="./multi_image_ct_crosshair.png" class="img-fluid"></p>
<blockquote class="blockquote">
<p>Another frame from the openGL rendering cycle, highlighting PET images with crosshair display in multi-image mode:</p>
</blockquote>
<p><img src="./pet_multi_image.png" class="img-fluid"></p>
</section>
<section id="adding-support-for-the-display-of-supervoxels-sv-with-borders-within-the-image-slices-to-better-understand-anatomical-regions-within-slices" class="level2">
<h2 class="anchored" data-anchor-id="adding-support-for-the-display-of-supervoxels-sv-with-borders-within-the-image-slices-to-better-understand-anatomical-regions-within-slices">6. Adding support for the display of <a href="https://doi.org/10.1016/j.cagd.2022.102080">SuperVoxels</a> sv with borders within the image slices to better understand anatomical regions within slices</h2>
<p>In enhancing MedEye3d’s functionality, supporting super voxels (sv) with boundaries becomes paramount. The sv rendering, effectively capturing gradients, serves as the cornerstone for detecting these boundaries within both MRI and PET volumes. Supervoxels, described either through indicator masks or meshes, encapsulate regions of interest with distinct image characteristics. By integrating boundary detection for super-voxels, MedEye3d can offer enhanced segmentation capabilities, enabling more precise delineation and analysis of anatomical structures and pathological regions within medical imaging data.</p>
<p><a href="https://www.sciencedirect.com/topics/computer-science/superpixel">Supervoxels</a> are basically a collection of voxels that share similar image properties. For example: in MRI scans of the brain cortex, super voxels could represent clusters of voxels corresponding to specific anatomical regions or functional areas. The main objective of this task was to add support for the display of super voxel-based segmentation of images, followed by some janitorial tasks:</p>
<ol type="1">
<li><p>Display of the borders of super-voxels (sv), extracted using the machine learning algorithms.</p></li>
<li><p>Checking image gradient agreement with super-voxel borders.</p></li>
</ol>
<p>This initial workflow involved, the initialization of relevant buffers in OpenGL for dynamic rendering of lines over the image display, namely vertex array buffers (vao), vertex buffers (vbo) and edge buffers (ebo). Further, these buffers are updated on a scroll event, where the information from the currently displayed slice is passed to the event handler, which invokes a function that updates the vertex buffer (vbo) with new vertices pertaining to the relevant slice number and planar view, precalculated from an <a href="https://www.neonscience.org/resources/learning-hub/tutorials/about-hdf5">HDF5</a> file during initialization of the visualizer. For instance, if the user is scrolling in the 3rd axis (transversal plane) and is currently on slice 40, the supervoxel display will pertain to edges specifically calculated for that specific slice in that plane.</p>
<p>Eventually, with ever so increasing number of attempts and a few hurdles along the way, one of which particularly stood out since it marked our first step towards a good direction:</p>
<blockquote class="blockquote">
<p>Challenges in rendering</p>
</blockquote>
<p><img src="./supervoxel_rendering_issue.png" class="img-fluid"></p>
<p>At last, an appealing result hit our sight.</p>
<blockquote class="blockquote">
<p>Final result</p>
</blockquote>
<blockquote class="blockquote">
<p><em>Note:</em> The image borders are intentional to emphasize the size of the visualizer which is currently defaulted to a certain width and height.</p>
</blockquote>
<p><img src="./supervoxel_rendering_fixed.png" class="img-fluid"></p>
<blockquote class="blockquote">
<p><em>Note:</em> However, There are a few things left to cover here, most of which revolve around MedImages.jl and documentation for the same. List of PRs that facilitated the completion of the tasks highlighted above:</p>
</blockquote>
<ol type="a">
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/21">https://github.com/JuliaHealth/MedEye3d.jl/pull/21</a></p></li>
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/20">https://github.com/JuliaHealth/MedEye3d.jl/pull/20</a></p></li>
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/16">https://github.com/JuliaHealth/MedEye3d.jl/pull/16</a></p></li>
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/14">https://github.com/JuliaHealth/MedEye3d.jl/pull/14</a></p></li>
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/13">https://github.com/JuliaHealth/MedEye3d.jl/pull/13</a></p></li>
<li><p><a href="https://github.com/JuliaHealth/MedEye3d.jl/pull/12">https://github.com/JuliaHealth/MedEye3d.jl/pull/12</a></p></li>
</ol>
</section>
</section>
<section id="contributions-beyond-coding" class="level1">
<h1>Contributions Beyond Coding</h1>
<section id="mentoring-and-guidance" class="level2">
<h2 class="anchored" data-anchor-id="mentoring-and-guidance">1. Mentoring and Guidance</h2>
<p>I regularly organized meetings with my mentor to seek guidance on project direction and troubleshooting issues in the visualizer. This ensured that I stayed on track, received timely feedback, and addressed any challenges that arose.</p>
</section>
<section id="package-documentation-and-community-contribution" class="level2">
<h2 class="anchored" data-anchor-id="package-documentation-and-community-contribution">2. Package Documentation and Community Contribution</h2>
<p>I contributed to other medical imaging sub-ecosystem packages in JuliaHealth, including <a href="https://github.com/Juliahealth/MedImages.jl">MedImages.jl</a> and <a href="https://github.com/Juliahealth/MedEval3D.jl">MedEval3D.jl</a>. Specifically, I set up documentation for these packages using DocuementerVitepress.jl. This not only enhanced the functionality of these packages but also helped maintain a coherent and organized package ecosystem.</p>
</section>
<section id="multirepo-management-and-collaboration" class="level2">
<h2 class="anchored" data-anchor-id="multirepo-management-and-collaboration">3. Multirepo Management and Collaboration</h2>
<p>In addition to my work on the MedEye3d visualizer, I made significant contributions to other JuliaHealth repositories, including <a href="https://github.com/JuliaHealth/MedImages.jl">MedImages.jl</a> and worked over an <a href="https://github.com/InsightSoftwareConsortium/ITK">Insight Toolkit</a> wrapper library <a href="https://github.com/JuliaHealth/ITKIOWrapper.jl">ITKIOWrapper.jl</a> for support in image I/O down the road in MedImages.jl. I also maintained relevant documentation and ensured continuous collaboration and synchronization across these packages.</p>
</section>
</section>
<section id="conclusions-and-future-development" class="level1">
<h1>Conclusions and Future Development</h1>
<p>Within the scope of this 350-hour project, a comprehensive range of objectives were successfully addressed. Noteworthy achievements include:</p>
<ol type="1">
<li><p>Fixed screen tear and flicker within the visualizer. Integration of threadsafe Julia channels.</p></li>
<li><p>Achieved multi-image display over CT and PET modalities with crosshair rendering (Although, only one modality can be visualize at a time, i.e either CT | CT or PET | PET).</p></li>
<li><p>Achieved supervoxel display in single image display mode.</p></li>
<li><p>Achieved automatic windowing of MRI and PET most common modalities.</p></li>
</ol>
<p>Future work would include:</p>
<ul>
<li><p>Support for the users on Darwin (Apple-based platforms).</p></li>
<li><p>Apart from that, we would need to add a function that dynamically allocates the texture number to the manual modification mask, regardless of the number of images passed for display, which is currently defaulted to 2.</p></li>
<li><p>Also, in the future, we would explore the stretch goals a bit more rigorously, particularly the implementation of <a href="https://doi.org/10.1016/j.softx.2024.101744">MedVoxelHD</a> within MedEye3d.</p></li>
</ul>
</section>
<section id="acknowledgements" class="level1">
<h1>Acknowledgements 🙇‍♂️</h1>
<ol type="1">
<li><p><a href="https://orcid.org/0000-0003-1823-6823">Jakub Mitura</a>: aka, <a href="https://github.com/jakubMitura14">Dr.&nbsp;Jakub Mitura</a></p></li>
<li><p><a href="https://scholar.google.com/citations?user=WzleS8YAAAAJ&amp;hl=en">Carlos Castillo Passi</a>: aka, <a href="https://github.com/cncastillo">cncastillo</a></p></li>
</ol>
<p>I would like to thank my mentor Dr.&nbsp;Jakub Mitura, for his help through out every phase of this project. The troubleshooting routines around problems would have rendered the project unsuccessful, if not for the support and guidance of my mentor throughout each part of this project. I would also like to thank Jacob Zelko, for leading the Juliahealth community with such vast expertise and leading efforts for engagement amongst the members through monthly meetings. My sincere gratitude towards your support, help and guidance through out the fellowship.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-Mitura2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">J. Mitura and B. E. Chrapko, <span>“3D medical segmentation visualization in julia with MedEye3d,”</span> <em>Zeszyty Naukowe Warszawskiej Wyższej Szkoły Informatyki</em>, vol. nr 25, pp. 57–67, 2021, doi: <a href="https://doi.org/10.26348/znwwsi.25.57">10.26348/znwwsi.25.57</a></div>
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{goyal2024,
  author = {Goyal, Divyansh},
  title = {GSoC ’24: {Adding} Functionalities to Medical Imaging
    Visualizations},
  date = {2024-11-01},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-goyal2024" class="csl-entry quarto-appendix-citeas" role="listitem">
<div class="">D.
Goyal, <span>“GSoC ’24: Adding functionalities to medical imaging
visualizations,”</span> Nov. 01, 2024.</div>
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="JuliaHealth/JuliaHealthBlog" issue-term="title" theme="github-dark" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024-25, JuliaHealth.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/JuliaHealth/JuliaHealthBlog">
<p>Report Issue</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>