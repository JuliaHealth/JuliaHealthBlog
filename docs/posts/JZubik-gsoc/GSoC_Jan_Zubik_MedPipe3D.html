<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Zubik">
<meta name="dcterms.date" content="2024-11-03">
<meta name="description" content="MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.">

<title>GSoC ’24: Adding dataset-wide functions and integrations of augmentations – The JuliaHealth Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dbcbc950a42bcaf185fdba3d0ea6113f.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-21ab05999d9ba4f3397b27295ec92d09.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "?"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script data-goatcounter="https://juliahealthblog.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="GSoC ’24: Adding dataset-wide functions and integrations of augmentations – The JuliaHealth Blog">
<meta property="og:description" content="MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.">
<meta property="og:image" content="https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/Augmentations.png">
<meta property="og:site_name" content="The JuliaHealth Blog">
<meta property="og:locale" content="en_EN">
<meta property="og:image:height" content="549">
<meta property="og:image:width" content="569">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../profile.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The JuliaHealth Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <span class="nav-link">
<span class="menu-text">Write with Us</span>
    </span>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-join-juliahealth" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Join JuliaHealth</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-join-juliahealth">    
        <li>
    <a class="dropdown-item" href="https://julialang.org/slack/"><i class="bi bi-slack" role="img">
</i> 
 <span class="dropdown-text">Slack (#health-and-medicine)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://julialang.zulipchat.com/"><i class="bi bi-lightning-charge-fill" role="img">
</i> 
 <span class="dropdown-text">Julia Zulip</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://discourse.julialang.org/"><i class="bi bi-pencil-square" role="img">
</i> 
 <span class="dropdown-text">Julia Discourse</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-github" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/JuliaHealth/JuliaHealthBlog">
 <span class="dropdown-text">Source Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose">
 <span class="dropdown-text">Report a Bug</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<b>Navigation &amp; Tips:</b>

<ul>
    <li>Press <b>?</b> for search</li>
    <li><b>"&lt;/&gt; Code"</b> for code nav</li>
</ul>

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section">📝🩻📎📉 ➡️ 🗃️📚♻️🧑‍🏫 ➡️ 🤖👁️📈 ➡️ ❤️‍🩹</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  </ul></li>
  <li><a href="#project-goals" id="toc-project-goals" class="nav-link" data-scroll-target="#project-goals">Project Goals</a></li>
  <li><a href="#tasks" id="toc-tasks" class="nav-link" data-scroll-target="#tasks">Tasks</a>
  <ul class="collapse">
  <li><a href="#integrate-augmentations-for-medical-data" id="toc-integrate-augmentations-for-medical-data" class="nav-link" data-scroll-target="#integrate-augmentations-for-medical-data">Integrate augmentations for medical data 🆙</a></li>
  <li><a href="#invertible-augmentations-and-support-test-time-augmentations" id="toc-invertible-augmentations-and-support-test-time-augmentations" class="nav-link" data-scroll-target="#invertible-augmentations-and-support-test-time-augmentations">Invertible augmentations and support test time augmentations 🆙</a></li>
  <li><a href="#patch-based-data-loading-with-probabilistic-oversampling" id="toc-patch-based-data-loading-with-probabilistic-oversampling" class="nav-link" data-scroll-target="#patch-based-data-loading-with-probabilistic-oversampling">Patch-based data loading with probabilistic oversampling ✅</a></li>
  <li><a href="#calculate-median-and-mean-spacing-with-resampling" id="toc-calculate-median-and-mean-spacing-with-resampling" class="nav-link" data-scroll-target="#calculate-median-and-mean-spacing-with-resampling">Calculate Median and Mean Spacing with resampling 🆙</a></li>
  <li><a href="#basic-post-processing-operations" id="toc-basic-post-processing-operations" class="nav-link" data-scroll-target="#basic-post-processing-operations">Basic Post-processing operations</a></li>
  <li><a href="#structured-configuration-of-all-hyperparameters" id="toc-structured-configuration-of-all-hyperparameters" class="nav-link" data-scroll-target="#structured-configuration-of-all-hyperparameters">Structured configuration of all hyperparameters 🆙</a></li>
  <li><a href="#visualization-of-algorithm-outputs" id="toc-visualization-of-algorithm-outputs" class="nav-link" data-scroll-target="#visualization-of-algorithm-outputs">Visualization of algorithm outputs ⚠️</a></li>
  <li><a href="#k-fold-cross-validation-functionality" id="toc-k-fold-cross-validation-functionality" class="nav-link" data-scroll-target="#k-fold-cross-validation-functionality">K-fold cross-validation functionality ✅</a></li>
  </ul></li>
  <li><a href="#conclusions-and-future-development" id="toc-conclusions-and-future-development" class="nav-link" data-scroll-target="#conclusions-and-future-development">Conclusions and Future Development</a></li>
  <li><a href="#future-development" id="toc-future-development" class="nav-link" data-scroll-target="#future-development">Future Development</a>
  <ul class="collapse">
  <li><a href="#necessary-enhancements" id="toc-necessary-enhancements" class="nav-link" data-scroll-target="#necessary-enhancements">Necessary Enhancements</a></li>
  <li><a href="#potential-enhancements" id="toc-potential-enhancements" class="nav-link" data-scroll-target="#potential-enhancements">Potential Enhancements</a></li>
  </ul></li>
  <li><a href="#acknowledgments" id="toc-acknowledgments" class="nav-link" data-scroll-target="#acknowledgments">Acknowledgments 🙇‍♂️</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/edit/main/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">GSoC ’24: Adding dataset-wide functions and integrations of augmentations</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">gsoc</div>
    <div class="quarto-category">AI/ML</div>
    <div class="quarto-category">imaging</div>
    <div class="quarto-category">gpu</div>
    <div class="quarto-category">analysis</div>
  </div>
  </div>

<div>
  <div class="description">
    MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jan Zubik </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 3, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="section" class="level1">
<h1>📝🩻📎📉 ➡️ 🗃️📚♻️🧑‍🏫 ➡️ 🤖👁️📈 ➡️ ❤️‍🩹</h1>
<p><em>These emoticons may resemble <strong>hieroglyphics</strong>, but very soon you will realize that they <strong>mean more than 1000s</strong> of lines of code.</em></p>
<details>
<summary>
Description of the emojis used in the title
</summary>
<ul>
<li>
📝 <strong>Action Plan</strong>: A clear, structured plan that guides each step of the MedPipe3D pipeline.
</li>
<li>
🩻 <strong>3D Medical Images</strong>: Medical imaging data, such as MRI scans in Nifti format.
</li>
<li>
📎 <strong>AI Model</strong>: The initial AI model that will be trained and refined within the pipeline.
</li>
<li>
📉 <strong>Loss Function</strong>: A function that measures the model’s performance during training, guiding the optimization process.
</li>
<li>
🗃️ <strong>Data Loading</strong>: Preparation and loading of data and metadata into HDF5 format.
</li>
<li>
📚 <strong>Data Splitting</strong>: Dividing data into training, validation, and test sets.
</li>
<li>
♻️ <strong>Data Augmentation</strong>: Increasing data variability through augmentation.
</li>
<li>
🧑‍🏫 <strong>AI Training</strong>: Using Lux.jl framework to train the AI model.
</li>
<li>
🤖 <strong>Model</strong>: The trained AI model that can perform tasks like segmentation on medical images.
</li>
<li>
👁️ <strong>Data for Visualization</strong>: Output data, such as masks and segmentations.
</li>
<li>
📈 <strong>Performance Logs</strong>: Logs and metrics documenting the AI’s performance.
</li>
<li>
❤️‍🩹 <strong>Purpose of MedPipe3D</strong>
</li>
</ul>
</details>
<hr>
<p>In this post, I’d like to summarize what I did this summer and everything I learned along the way, rebuilding the MedPipe3D medical imaging pipeline. I will not start typically, but so that anyone even a novice can visualize what this project has achieved, while the latter part is intended for more experienced readers. It will be easiest to divide it into 4 steps separated by ➡️ in the title above. Each emoji stands for a different piece of pipeliner and will be described below.</p>
<p>📝🩻📎📉 <strong>What we need from the user</strong></p>
<p>MedPipe3D requires four essential inputs from the user to get started: a clear action plan 📝, 3D medical images like MRI scans 🩻, an AI model 📎, and a loss function 📉.</p>
<p>🗃️📚♻️🧑‍🏫 <strong>The Pipeline essential AI manufacturing line</strong></p>
<p>Following the plan 📝, MedPipe3D loads data, pre-processes, and organizes it 🗃️. Allowing data to be easily split 📚, and efficiently augmented ♻️ in many ways for learning AI 🧑‍🏫 model effectively. In the end, performing testing and post-processing for better determination of AI skills.<br>
It’s designed to transform raw medical data into a format that your AI can learn from, segmenting meaningful patterns and structures.</p>
<p>🤖👁️📈 <strong>Results and Insights</strong></p>
<p>MedPipe3D is a tool for researchers and for that, it cannot do without analysis, testing, and evaluation. The result of the pipeline is a model 🤖 as well as data 👁️ and logs 📈 needed in MedEval3D that are ready for visualization and further analysis with MedEye3D. In a nutshell, it makes visualizing results easy, tumor locations or other medical features directly as masks on the scans.</p>
<p>❤️‍🩹 <strong>Purpose-Driven Technology</strong></p>
<p>MedPipe3D’s mission goes beyond technology. It’s about providing the tools to create AIs that support healthcare professionals in making faster, more accurate decisions, with the ultimate goal of saving lives.</p>
<p>This four-part journey captures the heart of the MedPipe3D toolkit for advancing medical AI, from raw data to life-saving insight.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><strong>MedPipe3D</strong> is a framework created from hundreds of hours over summer vacation, thousands of lines of code, hundreds of mistakes, and most importantly the guidance of my mentor and author of all of these libraries Dr.&nbsp;<a href="https://www.linkedin.com/in/jakub-mitura-7b2013151/">Jakub Mitura</a>. At its core, MedPipe3D combines sophisticated data handling from <strong>MedImage</strong> thanks to the hard work of <a href="https://www.linkedin.com/in/divyansh-goyal-34654b200/">Divyansh Goyal</a>. Newly developed pipeline for model training, validation, and testing with existing <strong>MedEval3D</strong>, and result visualization with <strong>MedEye3D</strong>. Unfortunately, not all of the project’s goals have been fully achieved, and thereby there is one section ➡️ too many. Hopefully not for long. My name is <a href="https://www.linkedin.com/in/janzubik/">Jan Zubik</a>, and I wrote this entire library from scratch, which is currently my most complex project.</p>
<p>If you are a data scientist, programmer, or code enthusiast, I invite you to read the next section where I go into detail and present <strong>version 1</strong> of this tool in detail.</p>
<p>I’m a 3rd-year student of BSc in Data Science and Machine Learning, I know that many things can be done better, expanded, debugged, and optimized. Now it just works, <strong>but don’t hesitate to write to me personally</strong> on <a href="https://www.linkedin.com/in/janzubik/">LinkedIn</a>, <a href="https://julialang.slack.com/team/U06L685B6TD">Julia’s Slack</a> or <a href="https://github.com/JanZubik">GitHub</a>! With your comments, and direct critique <strong>you will help me</strong> to be a better programmer and one day MedPipe3D will contribute in a tiny way to save someone’s life!</p>
<p>Exact work from the Google Summer of Code project you will find in <a href="https://github.com/JuliaHealth/MedPipe3D.jl/tree/GSoC-'24-MedPipe3D">GitHub the repository.</a></p>
</section>
</section>
<section id="project-goals" class="level1">
<h1>Project Goals</h1>
<p>The primary goal was to develop MedPipe3D and enhance MedImage, a Julia package designed to streamline the process of GPU-accelerated medical image segmentation. The project aimed to merge existing libraries—MedEye3D, MedEval3D, and MedImage—into a cohesive pipeline that facilitates advanced data handling, preprocessing, augmentation, model training, validation, testing with post-processing and visualization for medical imaging applications.</p>
</section>
<section id="tasks" class="level1">
<h1>Tasks</h1>
<ul>
<li>🆙 - Fully finished, with great potential for further development</li>
<li>✅ - Fully completed</li>
<li>⚠️ - Partially uncompleted</li>
<li>❌ - Unreached</li>
</ul>
Full list of all major parts and minor tasks (all tasks set up in the original GSOC plan were completed at least minimum level, and many additional improvements above minimum were implemented)
<details>
<ol type="1">
<li><strong>Helpful functions to support the MedImage format ✅</strong></li>
</ol>
<ul>
<li>Debugging rotations ✅</li>
<li>Crop MedImage or 3D array ✅</li>
<li>Pad MedImage or 3D array ✅</li>
<li>Pad with edge values ✅</li>
<li>Calculating the average of the edges of the picture 🆙</li>
</ul>
<ol start="2" type="1">
<li><strong>Integrate Augmentations for Medical Data ✅</strong></li>
</ol>
<ul>
<li>Brightness transform ✅</li>
<li>Contrast augmentation transform ✅</li>
<li>Gamma Transform ✅</li>
<li>Gaussian noise transform ✅</li>
<li>Rician noise transform ✅</li>
<li>Mirror transform ✅</li>
<li>Scale transform 🆙</li>
<li>Gaussian blur transform ✅</li>
<li>Simulate low-resolution transform 🆙</li>
<li>Elastic deformation transform 🆙</li>
</ul>
<ol start="3" type="1">
<li><strong>Develop a Pipeline ⚠️</strong></li>
</ol>
<ul>
<li>Structured configuration of all hyperparameters 🆙</li>
<li>Interactive creation of configuration ✅</li>
<li>Creating a structured configuration of hyperparameters in JSON 🆙</li>
<li>Loading data into HDF5 ✅
<ul>
<li>Cropping and padding to real coordinates of the main picture ✅</li>
<li>Calculate Median and Mean Spacing with resampling 🆙</li>
<li>Cropping and padding to specific or average dimensions ✅</li>
<li>Standardization and normalization ✅</li>
</ul></li>
<li>Managing index groups (channels) for batch requirements in HDF5 ✅
<ul>
<li>Divide into train, validation, test specified as % ✅</li>
<li>Divide with a specific division specified in JSON ✅</li>
<li>Equal distribution when there are multiple classes ✅</li>
</ul></li>
<li>Extracting data and creating 5-dimensional tensors for batched learning ✅
<ul>
<li>Hole images data loading ✅</li>
<li>Patch-based data loading with probabilistic oversampling ✅</li>
</ul></li>
<li>Obtaining the necessary elements for learning ✅
<ul>
<li>Get optimizer, loss function, and performance metrics ✅</li>
</ul></li>
<li>Apply augmentations ✅</li>
<li>Train ✅
<ul>
<li>Initializing model ✅</li>
<li>The learning epoch ✅</li>
<li>Epoch with early stopping functionality ✅</li>
</ul></li>
<li>Inferring ✅</li>
<li>Validation ✅
<ul>
<li>Evaluate metric ✅</li>
<li>Evaluate validation loss ✅</li>
<li>Validation with largest connected component✅</li>
</ul></li>
<li>Testing ✅
<ul>
<li>Evaluate test set ✅</li>
<li>Invertible augmentations evaluation ✅</li>
<li>Patch-based invertible augmentations evaluation ✅</li>
</ul></li>
<li>Logging ⚠️
<ul>
<li>Returning the necessary results ⚠️</li>
<li>Logging connection to TensorBoard ❌</li>
<li>Logging errors and warnings ❌</li>
</ul></li>
<li>Visualization ⚠️
<ul>
<li>Returning data in Nifti format ✅</li>
<li>Automated visualization in MedEye3D ❌</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li><strong>Optimize Performance with GPU Acceleration</strong>
<ul>
<li>Augmentations ✅</li>
<li>Learning, Validation, Testing ✅</li>
<li>Largest connected component ✅</li>
</ul></li>
<li><strong>Documentation ⚠️</strong>
<ul>
<li>Comments in important places in the code ⚠️</li>
<li>Documentation of the function ⚠️</li>
<li>Read me ⚠️</li>
<li>Documentation on juliahealth.org ❌</li>
</ul></li>
</ol>
</details>
<section id="integrate-augmentations-for-medical-data" class="level2">
<h2 class="anchored" data-anchor-id="integrate-augmentations-for-medical-data">Integrate augmentations for medical data 🆙</h2>
<p>Augmenting medical data is a crucial step for enhancing model robustness, especially given the variations in imaging conditions and patient anatomy.</p>
<ul>
<li>This pipeline currently supports multiple augmentation techniques:
<ul>
<li>Brightness transform ✅</li>
<li>Contrast augmentation transform ✅</li>
<li>Gamma Transform ✅</li>
<li>Gaussian noise transform ✅</li>
<li>Rician noise transform ✅</li>
<li>Mirror transform ✅</li>
<li>Scale transform 🆙</li>
<li>Gaussian blur transform ✅</li>
<li>Simulate low-resolution transform 🆙</li>
<li>Elastic deformation transform 🆙</li>
</ul></li>
</ul>
<p>Which have been fully integrated. Each of these methods helps the model generalize better by simulating diverse imaging scenarios.</p>
<p><img src="./Augmentations.png" class="img-fluid"></p>
<p>Comments:</p>
<p>Augmentations such as scaling, and low-resolution simulation use interpolation that is not yet GPU-accelerated.</p>
<p>Elastic deformation with simulation of different tissue elasticities is a potential development opportunity that would further improve the model’s adaptability by mimicking more complex variations found in medical imaging.</p>
</section>
<section id="invertible-augmentations-and-support-test-time-augmentations" class="level2">
<h2 class="anchored" data-anchor-id="invertible-augmentations-and-support-test-time-augmentations">Invertible augmentations and support test time augmentations 🆙</h2>
<p>This section focuses on the ability to apply reversible augmentations to test data, allowing the model to be evaluated with different transformations. Only rotation is available at this time. The function <code>evaluate_patches</code> performs this evaluation by applying specified augmentations, dividing the test data into patches, and reconstructing the full image from the patches. During testing, one can choose to use of largest connected component post-processing. Metrics are calculated and results are saved for analysis.</p>
<details>
<summary>
evaluate_test:
</summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># ...</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="cf">for</span> test_group <span class="kw">in</span> test_groups</span>
<span id="cb1-3"><a href="#cb1-3"></a>    test_data, test_label, attributes <span class="op">=</span> <span class="fu">fetch_and_preprocess_data</span>([test_group], h5, config)</span>
<span id="cb1-4"><a href="#cb1-4"></a>    results, test_metrics <span class="op">=</span> <span class="fu">evaluate_patches</span>(test_data, test_label,  tstate, model, config)</span>
<span id="cb1-5"><a href="#cb1-5"></a>    y_pred, metr <span class="op">=</span> <span class="fu">process_results</span>(results, test_metrics, config)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="fu">save_results</span>(y_pred, attributes, config)</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="fu">push!</span>(all_test_metrics, metr)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="cf">end</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># ...</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">function</span> <span class="fu">evaluate_patches</span>(test_data, test_label, tstate, model, config, axis, angle)</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="fu">println</span>(<span class="st">"Evaluating patches..."</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>    results <span class="op">=</span> []</span>
<span id="cb2-4"><a href="#cb2-4"></a>    test_metrics <span class="op">=</span> []</span>
<span id="cb2-5"><a href="#cb2-5"></a>    tstates <span class="op">=</span> [tstate]</span>
<span id="cb2-6"><a href="#cb2-6"></a>    test_time_augs <span class="op">=</span> []</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="cf">for</span> i <span class="kw">in</span> config[<span class="st">"learning"</span>][<span class="st">"n_invertible"</span>]</span>
<span id="cb2-9"><a href="#cb2-9"></a>        data <span class="op">=</span> <span class="fu">rotate_mi</span>(test_data, axis, angle)</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="cf">for</span> tstate_curr <span class="kw">in</span> tstates</span>
<span id="cb2-11"><a href="#cb2-11"></a>            patch_results <span class="op">=</span> []</span>
<span id="cb2-12"><a href="#cb2-12"></a>            patch_size <span class="op">=</span> <span class="fu">Tuple</span>(config[<span class="st">"learning"</span>][<span class="st">"patch_size"</span>])</span>
<span id="cb2-13"><a href="#cb2-13"></a>            idx_and_patches, paded_data_size <span class="op">=</span> <span class="fu">divide_into_patches</span>(test_data, patch_size)</span>
<span id="cb2-14"><a href="#cb2-14"></a>            coordinates <span class="op">=</span> [patch[<span class="fl">1</span>] for patch <span class="kw">in</span> idx_and_patches]</span>
<span id="cb2-15"><a href="#cb2-15"></a>            patch_data <span class="op">=</span> [patch[<span class="fl">2</span>] for patch <span class="kw">in</span> idx_and_patches]</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span class="cf">for</span> patch <span class="kw">in</span> patch_data</span>
<span id="cb2-17"><a href="#cb2-17"></a>                y_pred_patch, _ <span class="op">=</span> <span class="fu">infer_model</span>(tstate_curr, model, patch)</span>
<span id="cb2-18"><a href="#cb2-18"></a>                <span class="fu">push!</span>(patch_results, y_pred_patch)</span>
<span id="cb2-19"><a href="#cb2-19"></a>            <span class="cf">end</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>            idx_and_y_pred_patch <span class="op">=</span> <span class="fu">zip</span>(coordinates, patch_results)</span>
<span id="cb2-21"><a href="#cb2-21"></a>            y_pred <span class="op">=</span> <span class="fu">recreate_image_from_patches</span>(idx_and_y_pred_patch, paded_data_size, patch_size, <span class="fu">size</span>(test_data))</span>
<span id="cb2-22"><a href="#cb2-22"></a>            <span class="cf">if</span> config[<span class="st">"learning"</span>][<span class="st">"largest_connected_component"</span>]</span>
<span id="cb2-23"><a href="#cb2-23"></a>                y_pred <span class="op">=</span> <span class="fu">largest_connected_component</span>(y_pred, config[<span class="st">"learning"</span>][<span class="st">"n_lcc"</span>])</span>
<span id="cb2-24"><a href="#cb2-24"></a>            <span class="cf">end</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>            metr <span class="op">=</span> <span class="fu">evaluate_metric</span>(y_pred, test_label, config[<span class="st">"learning"</span>][<span class="st">"metric"</span>])</span>
<span id="cb2-26"><a href="#cb2-26"></a>            <span class="fu">push!</span>(test_metrics, metr)</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">end</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="cf">end</span></span>
<span id="cb2-29"><a href="#cb2-29"></a>    <span class="cf">return</span> results, test_metrics</span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">function</span> <span class="fu">divide_into_patches</span>(image<span class="op">::</span><span class="dt">AbstractArray{T, 5}</span>, patch_size<span class="op">::</span><span class="dt">Tuple{Int, Int, Int}</span>) <span class="kw">where</span> T</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="fu">println</span>(<span class="st">"Dividing image into patches..."</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="fu">println</span>(<span class="st">"Size of the image: "</span>, <span class="fu">size</span>(image)) </span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co"># Calculate the required padding for each dimension (W, H, D)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    pad_size <span class="op">=</span> (</span>
<span id="cb3-7"><a href="#cb3-7"></a>        (<span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">%</span> patch_size[<span class="fl">1</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">1</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">%</span> patch_size[<span class="fl">1</span>] <span class="op">:</span> <span class="fl">0</span>,</span>
<span id="cb3-8"><a href="#cb3-8"></a>        (<span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">%</span> patch_size[<span class="fl">2</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">2</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">%</span> patch_size[<span class="fl">2</span>] <span class="op">:</span> <span class="fl">0</span>,</span>
<span id="cb3-9"><a href="#cb3-9"></a>        (<span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">%</span> patch_size[<span class="fl">3</span>]) <span class="op">!=</span> <span class="fl">0</span> ? patch_size[<span class="fl">3</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">%</span> patch_size[<span class="fl">3</span>] <span class="op">:</span> <span class="fl">0</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    )</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="co"># Pad the image if necessary</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    padded_image <span class="op">=</span> image</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">if</span> <span class="fu">any</span>(pad_size <span class="op">.&gt;</span> <span class="fl">0</span>)</span>
<span id="cb3-15"><a href="#cb3-15"></a>        padded_image <span class="op">=</span> <span class="fu">crop_or_pad</span>(image, (<span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">+</span> pad_size[<span class="fl">1</span>], <span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">+</span> pad_size[<span class="fl">2</span>], <span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">+</span> pad_size[<span class="fl">3</span>]))</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">end</span></span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="co"># Extract patches</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    patches <span class="op">=</span> []</span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">1</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">1</span>)</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="cf">for</span> y <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">2</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">2</span>)</span>
<span id="cb3-22"><a href="#cb3-22"></a>            <span class="cf">for</span> z <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>patch_size[<span class="fl">3</span>]<span class="op">:</span><span class="fu">size</span>(padded_image, <span class="fl">3</span>)</span>
<span id="cb3-23"><a href="#cb3-23"></a>                patch <span class="op">=</span> <span class="fu">view</span>(</span>
<span id="cb3-24"><a href="#cb3-24"></a>                    padded_image,</span>
<span id="cb3-25"><a href="#cb3-25"></a>                    x<span class="op">:</span><span class="fu">min</span>(x<span class="op">+</span>patch_size[<span class="fl">1</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">1</span>)),</span>
<span id="cb3-26"><a href="#cb3-26"></a>                    y<span class="op">:</span><span class="fu">min</span>(y<span class="op">+</span>patch_size[<span class="fl">2</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">2</span>)),</span>
<span id="cb3-27"><a href="#cb3-27"></a>                    z<span class="op">:</span><span class="fu">min</span>(z<span class="op">+</span>patch_size[<span class="fl">3</span>]<span class="op">-</span><span class="fl">1</span>, <span class="fu">size</span>(padded_image, <span class="fl">3</span>)),</span>
<span id="cb3-28"><a href="#cb3-28"></a>                    <span class="op">:</span>,</span>
<span id="cb3-29"><a href="#cb3-29"></a>                    <span class="op">:</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>                )</span>
<span id="cb3-31"><a href="#cb3-31"></a>                <span class="fu">push!</span>(patches, [(x, y, z), patch])</span>
<span id="cb3-32"><a href="#cb3-32"></a>            <span class="cf">end</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>        <span class="cf">end</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>    <span class="cf">end</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>    <span class="fu">println</span>(<span class="st">"Size of padded image: "</span>, <span class="fu">size</span>(padded_image))</span>
<span id="cb3-36"><a href="#cb3-36"></a>    <span class="cf">return</span> patches, <span class="fu">size</span>(padded_image)</span>
<span id="cb3-37"><a href="#cb3-37"></a><span class="kw">end</span></span>
<span id="cb3-38"><a href="#cb3-38"></a></span>
<span id="cb3-39"><a href="#cb3-39"></a><span class="kw">function</span> <span class="fu">recreate_image_from_patches</span>(</span>
<span id="cb3-40"><a href="#cb3-40"></a>    coords_with_patches,</span>
<span id="cb3-41"><a href="#cb3-41"></a>    padded_size,</span>
<span id="cb3-42"><a href="#cb3-42"></a>    patch_size,</span>
<span id="cb3-43"><a href="#cb3-43"></a>    original_size</span>
<span id="cb3-44"><a href="#cb3-44"></a>)</span>
<span id="cb3-45"><a href="#cb3-45"></a>    <span class="fu">println</span>(<span class="st">"Recreating image from patches..."</span>)</span>
<span id="cb3-46"><a href="#cb3-46"></a>    reconstructed_image <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float32</span>, padded_size<span class="op">...</span>)</span>
<span id="cb3-47"><a href="#cb3-47"></a>    </span>
<span id="cb3-48"><a href="#cb3-48"></a>    <span class="co"># Place patches back into their original positions</span></span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="cf">for</span> (coords, patch) <span class="kw">in</span> coords_with_patches</span>
<span id="cb3-50"><a href="#cb3-50"></a>        x, y, z <span class="op">=</span> coords</span>
<span id="cb3-51"><a href="#cb3-51"></a>        reconstructed_image[</span>
<span id="cb3-52"><a href="#cb3-52"></a>            x<span class="op">:</span>x<span class="op">+</span>patch_size[<span class="fl">1</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-53"><a href="#cb3-53"></a>            y<span class="op">:</span>y<span class="op">+</span>patch_size[<span class="fl">2</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-54"><a href="#cb3-54"></a>            z<span class="op">:</span>z<span class="op">+</span>patch_size[<span class="fl">3</span>]<span class="op">-</span><span class="fl">1</span>,</span>
<span id="cb3-55"><a href="#cb3-55"></a>            <span class="op">:</span>,</span>
<span id="cb3-56"><a href="#cb3-56"></a>            <span class="op">:</span></span>
<span id="cb3-57"><a href="#cb3-57"></a>        ] <span class="op">=</span> patch</span>
<span id="cb3-58"><a href="#cb3-58"></a>    <span class="cf">end</span></span>
<span id="cb3-59"><a href="#cb3-59"></a></span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="co"># Crop the reconstructed image to remove any padding</span></span>
<span id="cb3-61"><a href="#cb3-61"></a>    final_image <span class="op">=</span> reconstructed_image[</span>
<span id="cb3-62"><a href="#cb3-62"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">1</span>],</span>
<span id="cb3-63"><a href="#cb3-63"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">2</span>],</span>
<span id="cb3-64"><a href="#cb3-64"></a>        <span class="fl">1</span><span class="op">:</span>original_size[<span class="fl">3</span>],</span>
<span id="cb3-65"><a href="#cb3-65"></a>        <span class="op">:</span>,</span>
<span id="cb3-66"><a href="#cb3-66"></a>        <span class="op">:</span></span>
<span id="cb3-67"><a href="#cb3-67"></a>    ]</span>
<span id="cb3-68"><a href="#cb3-68"></a>    <span class="fu">println</span>(<span class="st">"Size of the final image: "</span>, <span class="fu">size</span>(final_image))</span>
<span id="cb3-69"><a href="#cb3-69"></a>    <span class="cf">return</span> final_image</span>
<span id="cb3-70"><a href="#cb3-70"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> In this section, there is significant potential to incorporate additional types of invertible augmentations.</p>
</section>
<section id="patch-based-data-loading-with-probabilistic-oversampling" class="level2">
<h2 class="anchored" data-anchor-id="patch-based-data-loading-with-probabilistic-oversampling">Patch-based data loading with probabilistic oversampling ✅</h2>
<p>In this section, patches are extracted using <code>extract_patch</code> from the medical images for model training, with a probability-based method to decide between a random patch or a patch with non-zero labels. Helper functions like <code>get_random_patch</code> and <code>get_centered_patch</code> determine the starting indices and dimensions for the patches based on given configurations, while padding methods ensure consistency even if the patch exceeds the original image dimensions. Probabilistic oversampling, as configured, allows for more balanced and informative data sampling, which improves the model’s ability to detect specific medical features.</p>
<details>
<summary>
extract_patch:
</summary>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">function</span> <span class="fu">extract_patch</span>(image, label, patch_size, config)</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="co"># Fetch the oversampling probability from the config</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="fu">println</span>(<span class="st">"Extracting patch."</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>    oversampling_probability <span class="op">=</span> config[<span class="st">"learning"</span>][<span class="st">"oversampling_probability"</span>]</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="co"># Generate a random number to decide which patch extraction method to use</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    random_choice <span class="op">=</span> <span class="fu">rand</span>()</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="cf">if</span> random_choice <span class="op">&lt;=</span> oversampling_probability</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="cf">return</span> <span class="fu">extract_nonzero_patch</span>(image, label, patch_size)</span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="cf">else</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="cf">return</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="cf">end</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="kw">end</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#Helper function, in case the mask is emptyClick to apply</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="kw">function</span> <span class="fu">extract_nonzero_patch</span>(image, label, patch_size)</span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="fu">println</span>(<span class="st">"Extracting a patch centered around a non-zero label value."</span>)</span>
<span id="cb4-18"><a href="#cb4-18"></a>    indices <span class="op">=</span> <span class="fu">findall</span>(x <span class="op">-&gt;</span> x <span class="op">!=</span> <span class="fl">0</span>, label)</span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="cf">if</span> <span class="fu">isempty</span>(indices)</span>
<span id="cb4-20"><a href="#cb4-20"></a>        <span class="co"># Fallback to random patch if no non-zero points are found</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>        <span class="cf">return</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-22"><a href="#cb4-22"></a>    <span class="cf">else</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>        <span class="co"># Choose a random non-zero index to center the patch around</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>        center <span class="op">=</span> indices[<span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(indices))]</span>
<span id="cb4-25"><a href="#cb4-25"></a>        <span class="cf">return</span> <span class="fu">get_centered_patch</span>(image, label, center, patch_size)</span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="cf">end</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="kw">end</span></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="co"># Function to get a patch centered around a specific index</span></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="kw">function</span> <span class="fu">get_centered_patch</span>(image, label, center, patch_size)</span>
<span id="cb4-30"><a href="#cb4-30"></a>    center_coords <span class="op">=</span> <span class="fu">Tuple</span>(center)</span>
<span id="cb4-31"><a href="#cb4-31"></a>    half_patch <span class="op">=</span> patch_size <span class="op">.÷</span> <span class="fl">2</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>    start_indices <span class="op">=</span> center_coords <span class="op">.-</span> half_patch</span>
<span id="cb4-33"><a href="#cb4-33"></a>    end_indices <span class="op">=</span> start_indices <span class="op">.+</span> patch_size <span class="op">.-</span> <span class="fl">1</span></span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>    pad_beg <span class="op">=</span> (</span>
<span id="cb4-37"><a href="#cb4-37"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">1</span>], <span class="fl">0</span>),</span>
<span id="cb4-38"><a href="#cb4-38"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">2</span>], <span class="fl">0</span>),</span>
<span id="cb4-39"><a href="#cb4-39"></a>        <span class="fu">max</span>(<span class="fl">1</span> <span class="op">-</span> start_indices[<span class="fl">3</span>], <span class="fl">0</span>)</span>
<span id="cb4-40"><a href="#cb4-40"></a>    )</span>
<span id="cb4-41"><a href="#cb4-41"></a>    pad_end <span class="op">=</span> (</span>
<span id="cb4-42"><a href="#cb4-42"></a>        <span class="fu">max</span>(end_indices[<span class="fl">1</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">1</span>), <span class="fl">0</span>),</span>
<span id="cb4-43"><a href="#cb4-43"></a>        <span class="fu">max</span>(end_indices[<span class="fl">2</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">2</span>), <span class="fl">0</span>),</span>
<span id="cb4-44"><a href="#cb4-44"></a>        <span class="fu">max</span>(end_indices[<span class="fl">3</span>] <span class="op">-</span> <span class="fu">size</span>(image, <span class="fl">3</span>), <span class="fl">0</span>)</span>
<span id="cb4-45"><a href="#cb4-45"></a>    )</span>
<span id="cb4-46"><a href="#cb4-46"></a></span>
<span id="cb4-47"><a href="#cb4-47"></a>    <span class="co"># Adjust start_indices and end_indices after padding</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>    start_indices_adj <span class="op">=</span> start_indices <span class="op">.+</span> pad_beg</span>
<span id="cb4-49"><a href="#cb4-49"></a>    end_indices_adj <span class="op">=</span> end_indices <span class="op">.+</span> pad_beg</span>
<span id="cb4-50"><a href="#cb4-50"></a></span>
<span id="cb4-51"><a href="#cb4-51"></a>    <span class="co"># Convert padding values to integers</span></span>
<span id="cb4-52"><a href="#cb4-52"></a>    pad_beg <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">round</span>.(<span class="dt">Int</span>, pad_beg))</span>
<span id="cb4-53"><a href="#cb4-53"></a>    pad_end <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">round</span>.(<span class="dt">Int</span>, pad_end))</span>
<span id="cb4-54"><a href="#cb4-54"></a></span>
<span id="cb4-55"><a href="#cb4-55"></a>    <span class="co"># Pad the image and label using pad_mi</span></span>
<span id="cb4-56"><a href="#cb4-56"></a>    image_padded <span class="op">=</span> <span class="fu">pad_mi</span>(image, pad_beg, pad_end, <span class="fl">0</span>)</span>
<span id="cb4-57"><a href="#cb4-57"></a>    label_padded <span class="op">=</span> <span class="fu">pad_mi</span>(label, pad_beg, pad_end, <span class="fl">0</span>)</span>
<span id="cb4-58"><a href="#cb4-58"></a></span>
<span id="cb4-59"><a href="#cb4-59"></a>    <span class="co"># Extract the patch</span></span>
<span id="cb4-60"><a href="#cb4-60"></a>    image_patch <span class="op">=</span> image_padded[</span>
<span id="cb4-61"><a href="#cb4-61"></a>        start_indices_adj[<span class="fl">1</span>]<span class="op">:</span>end_indices_adj[<span class="fl">1</span>],</span>
<span id="cb4-62"><a href="#cb4-62"></a>        start_indices_adj[<span class="fl">2</span>]<span class="op">:</span>end_indices_adj[<span class="fl">2</span>],</span>
<span id="cb4-63"><a href="#cb4-63"></a>        start_indices_adj[<span class="fl">3</span>]<span class="op">:</span>end_indices_adj[<span class="fl">3</span>]</span>
<span id="cb4-64"><a href="#cb4-64"></a>    ]</span>
<span id="cb4-65"><a href="#cb4-65"></a>    label_patch <span class="op">=</span> label_padded[</span>
<span id="cb4-66"><a href="#cb4-66"></a>        start_indices_adj[<span class="fl">1</span>]<span class="op">:</span>end_indices_adj[<span class="fl">1</span>],</span>
<span id="cb4-67"><a href="#cb4-67"></a>        start_indices_adj[<span class="fl">2</span>]<span class="op">:</span>end_indices_adj[<span class="fl">2</span>],</span>
<span id="cb4-68"><a href="#cb4-68"></a>        start_indices_adj[<span class="fl">3</span>]<span class="op">:</span>end_indices_adj[<span class="fl">3</span>]</span>
<span id="cb4-69"><a href="#cb4-69"></a>    ]</span>
<span id="cb4-70"><a href="#cb4-70"></a></span>
<span id="cb4-71"><a href="#cb4-71"></a>    <span class="cf">return</span> image_patch, label_patch</span>
<span id="cb4-72"><a href="#cb4-72"></a><span class="kw">end</span></span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a><span class="kw">function</span> <span class="fu">get_random_patch</span>(image, label, patch_size)</span>
<span id="cb4-75"><a href="#cb4-75"></a>    <span class="fu">println</span>(<span class="st">"Extracting a random patch."</span>)</span>
<span id="cb4-76"><a href="#cb4-76"></a>    <span class="co"># Check if the patch size is greater than the image dimensions</span></span>
<span id="cb4-77"><a href="#cb4-77"></a>    <span class="cf">if</span> <span class="fu">any</span>(patch_size <span class="op">.&gt;</span> <span class="fu">size</span>(image))</span>
<span id="cb4-78"><a href="#cb4-78"></a>        <span class="co"># Calculate the needed size to fit the patch</span></span>
<span id="cb4-79"><a href="#cb4-79"></a>        needed_size <span class="op">=</span> <span class="fu">map</span>(max, <span class="fu">size</span>(image), patch_size)</span>
<span id="cb4-80"><a href="#cb4-80"></a>        <span class="co"># Use crop_or_pad to ensure the image and label are at least as large as needed_size</span></span>
<span id="cb4-81"><a href="#cb4-81"></a>        image <span class="op">=</span> <span class="fu">crop_or_pad</span>(image, needed_size)</span>
<span id="cb4-82"><a href="#cb4-82"></a>        label <span class="op">=</span> <span class="fu">crop_or_pad</span>(label, needed_size)</span>
<span id="cb4-83"><a href="#cb4-83"></a>    <span class="cf">end</span></span>
<span id="cb4-84"><a href="#cb4-84"></a></span>
<span id="cb4-85"><a href="#cb4-85"></a>    <span class="co"># Calculate random start indices within the new allowable range</span></span>
<span id="cb4-86"><a href="#cb4-86"></a>    start_x <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">1</span>) <span class="op">-</span> patch_size[<span class="fl">1</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-87"><a href="#cb4-87"></a>    start_y <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">2</span>) <span class="op">-</span> patch_size[<span class="fl">2</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-88"><a href="#cb4-88"></a>    start_z <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fu">size</span>(image, <span class="fl">3</span>) <span class="op">-</span> patch_size[<span class="fl">3</span>] <span class="op">+</span> <span class="fl">1</span>)</span>
<span id="cb4-89"><a href="#cb4-89"></a>    start_indices <span class="op">=</span> [start_x, start_y, start_z]</span>
<span id="cb4-90"><a href="#cb4-90"></a>    end_indices <span class="op">=</span> start_indices <span class="op">.+</span> patch_size <span class="op">.-</span> <span class="fl">1</span></span>
<span id="cb4-91"><a href="#cb4-91"></a></span>
<span id="cb4-92"><a href="#cb4-92"></a>    <span class="co"># Extract the patch directly when within bounds</span></span>
<span id="cb4-93"><a href="#cb4-93"></a>    image_patch <span class="op">=</span> image[start_indices[<span class="fl">1</span>]<span class="op">:</span>end_indices[<span class="fl">1</span>], start_indices[<span class="fl">2</span>]<span class="op">:</span>end_indices[<span class="fl">2</span>], start_indices[<span class="fl">3</span>]<span class="op">:</span>end_indices[<span class="fl">3</span>]]</span>
<span id="cb4-94"><a href="#cb4-94"></a>    label_patch <span class="op">=</span> label[start_indices[<span class="fl">1</span>]<span class="op">:</span>end_indices[<span class="fl">1</span>], start_indices[<span class="fl">2</span>]<span class="op">:</span>end_indices[<span class="fl">2</span>], start_indices[<span class="fl">3</span>]<span class="op">:</span>end_indices[<span class="fl">3</span>]]</span>
<span id="cb4-95"><a href="#cb4-95"></a></span>
<span id="cb4-96"><a href="#cb4-96"></a>    <span class="cf">return</span> image_patch, label_patch</span>
<span id="cb4-97"><a href="#cb4-97"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="calculate-median-and-mean-spacing-with-resampling" class="level2">
<h2 class="anchored" data-anchor-id="calculate-median-and-mean-spacing-with-resampling">Calculate Median and Mean Spacing with resampling 🆙</h2>
<p>This part ensures that all images in the dataset have consistent real coordinates, spacing, and shape. It’s a critical factor in medical imaging for accurate analysis. Calculating and applying set values, median or mean across images ensures uniformity.</p>
<section id="resample-images-to-target-image" class="level4">
<h4 class="anchored" data-anchor-id="resample-images-to-target-image">Resample images to target image 🆙</h4>
<p>This step aligns each image to the reference coordinates of the main image, ensuring that all images share a common spatial alignment. The <code>resample_to_image</code> function from MedImage.jl is used here, applying interpolation to adjust each image.</p>
<details>
<summary>
resample_images_to_target:
</summary>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1"></a><span class="cf">if</span> resample_images_to_target <span class="op">&amp;&amp;</span> !<span class="fu">isempty</span>(Med_images)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="fu">println</span>(<span class="st">"Resampling </span><span class="sc">$</span>channel_type<span class="st"> files in channel '</span><span class="sc">$</span>channel_folder<span class="st">' to the first </span><span class="sc">$</span>channel_type<span class="st"> in the channel."</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>    reference_image <span class="op">=</span> Med_images[<span class="fl">1</span>]</span>
<span id="cb5-4"><a href="#cb5-4"></a>    Med_images <span class="op">=</span> [<span class="fu">resample_to_image</span>(reference_image, img, interpolator) for img <span class="kw">in</span> Med_images]</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> <code>Resample_to_image</code> uses interpolation that is not yet GPU-accelerated in this implementation, this step slows down the data preparation phase significantly.</p>
</section>
<section id="ensure-uniform-spacing-across-the-entire-dataset" class="level4">
<h4 class="anchored" data-anchor-id="ensure-uniform-spacing-across-the-entire-dataset">Ensure uniform spacing across the entire dataset 🆙</h4>
<p>This step brings all images to a consistent voxel spacing across the dataset using <code>resample_to_spacing</code> from MedImage.jl. This uniform spacing is crucial for creating a standardized dataset where each image voxel represents the same physical volume.</p>
<details>
<summary>
esample_to_spacing:
</summary>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1"></a><span class="cf">if</span> resample_images_spacing <span class="op">==</span> <span class="st">"set"</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="fu">println</span>(<span class="st">"Resampling all </span><span class="sc">$</span>channel_type<span class="st"> files to target spacing: </span><span class="sc">$</span>target_spacing<span class="st">"</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a>    target_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(s) <span class="cf">for</span> s <span class="kw">in</span> target_spacing)</span>
<span id="cb6-4"><a href="#cb6-4"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, target_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="st">"avg"</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="fu">println</span>(<span class="st">"Calculating average spacing across all </span><span class="sc">$</span>channel_type<span class="st"> files and resampling."</span>)</span>
<span id="cb6-7"><a href="#cb6-7"></a>    all_spacings <span class="op">=</span> [img.spacing for channel <span class="kw">in</span> channels_data for img <span class="kw">in</span> channel]</span>
<span id="cb6-8"><a href="#cb6-8"></a>    avg_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(<span class="fu">mean</span>(s)) <span class="cf">for</span> s <span class="kw">in</span> <span class="fu">zip</span>(all_spacings<span class="op">...</span>))</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="fu">println</span>(<span class="st">"Average spacing calculated: </span><span class="sc">$</span>avg_spacing<span class="st">"</span>)</span>
<span id="cb6-10"><a href="#cb6-10"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, avg_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="st">"median"</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="fu">println</span>(<span class="st">"Calculating median spacing across all </span><span class="sc">$</span>channel_type<span class="st"> files and resampling."</span>)</span>
<span id="cb6-13"><a href="#cb6-13"></a>    all_spacings <span class="op">=</span> [img.spacing for channel <span class="kw">in</span> channels_data for img <span class="kw">in</span> channel]</span>
<span id="cb6-14"><a href="#cb6-14"></a>    median_spacing <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Float32</span>(<span class="fu">median</span>(s)) <span class="cf">for</span> s <span class="kw">in</span> all_spacings)</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="fu">println</span>(<span class="st">"Median spacing calculated: </span><span class="sc">$</span>median_spacing<span class="st">"</span>)</span>
<span id="cb6-16"><a href="#cb6-16"></a>    channels_data <span class="op">=</span> [[<span class="fu">resample_to_spacing</span>(img, median_spacing, interpolator) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="cf">elseif</span> resample_images_spacing <span class="op">==</span> <span class="cn">false</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="fu">println</span>(<span class="st">"Skipping resampling of </span><span class="sc">$</span>channel_type<span class="st"> files."</span>)</span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="co"># No resampling will be applied, channels_data remains unchanged.</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comment:<br> <code>Resample_to_spacing</code> uses interpolation that is not yet GPU-accelerated in this implementation, this step slows down the data preparation phase significantly.</p>
</section>
<section id="resizing-all-channel-files-to-average-or-target-size" class="level4">
<h4 class="anchored" data-anchor-id="resizing-all-channel-files-to-average-or-target-size">Resizing all channel files to average or target size ✅</h4>
<p>To create a cohesive 5D tensor, all images in each channel are resized to a uniform shape, either the average size of all images or a specific target size. This resizing process uses <code>crop_or_pad</code>, ensuring that all images match the specified dimensions, making them suitable for model input.</p>
<details>
<summary>
crop_or_pad:
</summary>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1"></a><span class="cf">if</span> resample_size <span class="op">==</span> <span class="st">"avg"</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    sizes <span class="op">=</span> [<span class="fu">size</span>(img.voxel_data) for img <span class="kw">in</span> channels_data for img <span class="kw">in</span> img]  <span class="co"># Get sizes from all images</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    avg_dim <span class="op">=</span> <span class="fu">map</span>(mean, <span class="fu">zip</span>(sizes<span class="op">...</span>))</span>
<span id="cb7-4"><a href="#cb7-4"></a>    avg_dim <span class="op">=</span> <span class="fu">Tuple</span>(<span class="fu">Int</span>(<span class="fu">round</span>(d)) <span class="cf">for</span> d <span class="kw">in</span> avg_dim)</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="fu">println</span>(<span class="st">"Resizing all </span><span class="sc">$</span>channel_type<span class="st"> files to average dimension: </span><span class="sc">$</span>avg_dim<span class="st">"</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    channels_data <span class="op">=</span> [[<span class="fu">crop_or_pad</span>(img, avg_dim) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="cf">elseif</span> resample_size <span class="op">!=</span> <span class="st">"avg"</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    target_dim <span class="op">=</span> <span class="fu">Tuple</span>(resample_size)</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="fu">println</span>(<span class="st">"Resizing all </span><span class="sc">$</span>channel_type<span class="st"> files to target dimension: </span><span class="sc">$</span>target_dim<span class="st">"</span>)</span>
<span id="cb7-10"><a href="#cb7-10"></a>    channels_data <span class="op">=</span> [[<span class="fu">crop_or_pad</span>(img, target_dim) for img <span class="kw">in</span> channel] for channel <span class="kw">in</span> channels_data]</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
</section>
<section id="basic-post-processing-operations" class="level2">
<h2 class="anchored" data-anchor-id="basic-post-processing-operations">Basic Post-processing operations</h2>
<p>Post-processing operations involve the algorithm <code>largest_connected_components</code>. It is achieved by label initialization and propagation in the segmented mask. The <code>initialize_labels_kernel</code> function assigns unique labels to different regions.</p>
<details>
<summary>
initialize_labels_kernel:
</summary>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">@kernel</span> <span class="kw">function</span> <span class="fu">initialize_labels_kernel</span>(mask, labels, width, height, depth)</span>
<span id="cb8-2"><a href="#cb8-2"></a>    idx <span class="op">=</span> <span class="pp">@index</span>(Global, Cartesian)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    i <span class="op">=</span> idx[<span class="fl">1</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>    j <span class="op">=</span> idx[<span class="fl">2</span>]</span>
<span id="cb8-5"><a href="#cb8-5"></a>    k <span class="op">=</span> idx[<span class="fl">3</span>]</span>
<span id="cb8-6"><a href="#cb8-6"></a>    </span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="cf">if</span> i <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> k <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> k <span class="op">&lt;=</span> depth</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">if</span> mask[i, j, k] <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>            labels[i, j, k] <span class="op">=</span> i <span class="op">+</span> (j <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> width <span class="op">+</span> (k <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> width <span class="op">*</span> height</span>
<span id="cb8-10"><a href="#cb8-10"></a>        <span class="cf">else</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>            labels[i, j, k] <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>        <span class="cf">end</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="cf">end</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
Propagate_labels_kernel iteratively updates the labels to maintain connected regions. propagate_labels_kernel:
<details>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">@kernel</span> <span class="kw">function</span> <span class="fu">propagate_labels_kernel</span>(mask, labels, width, height, depth)</span>
<span id="cb9-2"><a href="#cb9-2"></a>    idx<span class="op">=</span> <span class="pp">@index</span>(Global, Cartesian)</span>
<span id="cb9-3"><a href="#cb9-3"></a>    i <span class="op">=</span> idx[<span class="fl">1</span>]</span>
<span id="cb9-4"><a href="#cb9-4"></a>    j <span class="op">=</span> idx[<span class="fl">2</span>]</span>
<span id="cb9-5"><a href="#cb9-5"></a>    k <span class="op">=</span> idx[<span class="fl">3</span>]</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="cf">if</span> i <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> i <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> j <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> k <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> k <span class="op">&lt;=</span> depth</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">if</span> mask[i, j, k] <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>            current_label <span class="op">=</span> labels[i, j, k]</span>
<span id="cb9-10"><a href="#cb9-10"></a>            <span class="cf">for</span> di <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>                <span class="cf">for</span> dj <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>                    <span class="cf">for</span> dk <span class="kw">in</span> <span class="op">-</span><span class="fl">1</span><span class="op">:</span><span class="fl">1</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>                        <span class="cf">if</span> di <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> dj <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> dk <span class="op">==</span> <span class="fl">0</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>                            <span class="cf">continue</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>                        <span class="cf">end</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>                        ni <span class="op">=</span> i <span class="op">+</span> di</span>
<span id="cb9-17"><a href="#cb9-17"></a>                        nj <span class="op">=</span> j <span class="op">+</span> dj</span>
<span id="cb9-18"><a href="#cb9-18"></a>                        nk <span class="op">=</span> k <span class="op">+</span> dk</span>
<span id="cb9-19"><a href="#cb9-19"></a>                        <span class="cf">if</span> ni <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> ni <span class="op">&lt;=</span> width <span class="op">&amp;&amp;</span> nj <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> nj <span class="op">&lt;=</span> height <span class="op">&amp;&amp;</span> nk <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> nk <span class="op">&lt;=</span> depth</span>
<span id="cb9-20"><a href="#cb9-20"></a>                            <span class="cf">if</span> mask[ni, nj, nk] <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> labels[ni, nj, nk] <span class="op">&lt;</span> current_label</span>
<span id="cb9-21"><a href="#cb9-21"></a>                                labels[i, j, k] <span class="op">=</span> labels[ni, nj, nk]</span>
<span id="cb9-22"><a href="#cb9-22"></a>                            <span class="cf">end</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>                        <span class="cf">end</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>                    <span class="cf">end</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>                <span class="cf">end</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>            <span class="cf">end</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>        <span class="cf">end</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>    <span class="cf">end</span></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>This process facilitates the identification of the largest connected components in 3D space, helping to isolate relevant medical structures, such as tumors, in the segmented mask. Allowing determining how many such areas are to be returned.</p>
<details>
<summary>
largest_connected_components:
</summary>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">function</span> <span class="fu">largest_connected_components</span>(mask<span class="op">::</span><span class="dt">Array{Int32, 3}</span>, n_lcc<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a>    width, height, depth <span class="op">=</span> <span class="fu">size</span>(mask)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    mask_gpu <span class="op">=</span> <span class="fu">CuArray</span>(mask)</span>
<span id="cb10-4"><a href="#cb10-4"></a>    labels_gpu <span class="op">=</span> CUDA.<span class="fu">fill</span>(<span class="fl">0</span>, <span class="fu">size</span>(mask))</span>
<span id="cb10-5"><a href="#cb10-5"></a>    dev <span class="op">=</span> <span class="fu">get_backend</span>(labels_gpu)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    ndrange <span class="op">=</span> (width, height, depth)</span>
<span id="cb10-7"><a href="#cb10-7"></a>    workgroupsize <span class="op">=</span> (<span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">3</span>)</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="co"># Initialize labels</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="fu">initialize_labels_kernel</span>(dev)(mask_gpu, labels_gpu, width, height, depth, ndrange <span class="op">=</span> ndrange)</span>
<span id="cb10-11"><a href="#cb10-11"></a>    CUDA.<span class="fu">synchronize</span>()</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="co"># Propagate labels iteratively</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span> </span>
<span id="cb10-15"><a href="#cb10-15"></a>        <span class="fu">propagate_labels_kernel</span>(dev, workgroupsize)(mask_gpu, labels_gpu, width, height, depth, ndrange <span class="op">=</span> ndrange)</span>
<span id="cb10-16"><a href="#cb10-16"></a>        CUDA.<span class="fu">synchronize</span>()</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="cf">end</span></span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="co"># Download labels back to CPU</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    labels_cpu <span class="op">=</span> <span class="fu">Array</span>(labels_gpu)</span>
<span id="cb10-21"><a href="#cb10-21"></a>    </span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="co"># Find all unique labels and their sizes</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>    unique_labels <span class="op">=</span> <span class="fu">unique</span>(labels_cpu)</span>
<span id="cb10-24"><a href="#cb10-24"></a>    label_sizes <span class="op">=</span> [(label, <span class="fu">count</span>(labels_cpu <span class="op">.==</span> label)) for label <span class="kw">in</span> unique_labels if label <span class="op">!=</span> <span class="fl">0</span>]</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="co"># Sort labels by size and get the top n_lcc</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="fu">sort!</span>(label_sizes, by <span class="op">=</span> x <span class="op">-&gt;</span> x[<span class="fl">2</span>], rev <span class="op">=</span> <span class="cn">true</span>)</span>
<span id="cb10-28"><a href="#cb10-28"></a>    top_labels <span class="op">=</span> label_sizes[<span class="fl">1</span><span class="op">:</span><span class="fu">min</span>(n_lcc, <span class="fu">length</span>(label_sizes))]</span>
<span id="cb10-29"><a href="#cb10-29"></a></span>
<span id="cb10-30"><a href="#cb10-30"></a>    <span class="co"># Create a mask for each of the top n_lcc components</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    components <span class="op">=</span> [labels_cpu <span class="op">.==</span> label[<span class="fl">1</span>] for label <span class="kw">in</span> top_labels]</span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="cf">return</span> components</span>
<span id="cb10-33"><a href="#cb10-33"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="structured-configuration-of-all-hyperparameters" class="level2">
<h2 class="anchored" data-anchor-id="structured-configuration-of-all-hyperparameters">Structured configuration of all hyperparameters 🆙</h2>
<p>Hyperparameters for the entire pipeline are stored in a JSON configuration file, enabling straightforward adjustments for experimentation (just swap values, save and resume the study). This structured setup allows easy modification of key parameters, such as data set preparation, training settings, data augmentation, and resampling options.</p>
<details>
<summary>
Example configuration:
</summary>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource json number-lines code-with-copy"><code class="sourceCode json"><span id="cb11-1"><a href="#cb11-1"></a><span class="fu">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="dt">"model"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>        <span class="dt">"patience"</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="dt">"early_stopping_metric"</span><span class="fu">:</span> <span class="st">"val_loss"</span><span class="fu">,</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="dt">"optimizer_name"</span><span class="fu">:</span> <span class="st">"Adam"</span><span class="fu">,</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="dt">"loss_function_name"</span><span class="fu">:</span> <span class="st">"l1"</span><span class="fu">,</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="dt">"early_stopping"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="dt">"early_stopping_min_delta"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.01</span><span class="fu">,</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="dt">"optimizer_args"</span><span class="fu">:</span> <span class="st">"lr=0.001"</span><span class="fu">,</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>        <span class="dt">"num_epochs"</span><span class="fu">:</span> <span class="dv">10</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="fu">},</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="dt">"data"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="dt">"batch_complete"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>        <span class="dt">"resample_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">200</span><span class="ot">,</span><span class="dv">101</span><span class="ot">,</span><span class="dv">49</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>        <span class="dt">"resample_to_target"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>        <span class="dt">"resample_to_spacing"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="dt">"batch_size"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>        <span class="dt">"standardization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>        <span class="dt">"target_spacing"</span><span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span></span>
<span id="cb11-20"><a href="#cb11-20"></a>        <span class="dt">"channel_size"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb11-21"><a href="#cb11-21"></a>        <span class="dt">"normalization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>        <span class="dt">"has_mask"</span><span class="fu">:</span> <span class="kw">true</span></span>
<span id="cb11-23"><a href="#cb11-23"></a>    <span class="fu">},</span></span>
<span id="cb11-24"><a href="#cb11-24"></a>    <span class="dt">"augmentation"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-25"><a href="#cb11-25"></a>        <span class="dt">"augmentations"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-26"><a href="#cb11-26"></a>            <span class="dt">"Brightness transform"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>                <span class="dt">"mode"</span><span class="fu">:</span> <span class="st">"additive"</span><span class="fu">,</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>                <span class="dt">"value"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>            <span class="fu">}</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>        <span class="fu">},</span></span>
<span id="cb11-31"><a href="#cb11-31"></a>        <span class="dt">"p_rand"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">5</span><span class="fu">,</span></span>
<span id="cb11-32"><a href="#cb11-32"></a>        <span class="dt">"processing_unit"</span><span class="fu">:</span> <span class="st">"GPU"</span><span class="fu">,</span></span>
<span id="cb11-33"><a href="#cb11-33"></a>        <span class="dt">"order"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb11-34"><a href="#cb11-34"></a>            <span class="st">"Brightness transform"</span></span>
<span id="cb11-35"><a href="#cb11-35"></a>        <span class="ot">]</span></span>
<span id="cb11-36"><a href="#cb11-36"></a>    <span class="fu">},</span></span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="dt">"learning"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb11-38"><a href="#cb11-38"></a>        <span class="dt">"Train_Val_Test_JSON"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-39"><a href="#cb11-39"></a>        <span class="dt">"largest_connected_component"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>        <span class="dt">"n_lcc"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb11-41"><a href="#cb11-41"></a>        <span class="dt">"n_folds"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb11-42"><a href="#cb11-42"></a>        <span class="dt">"invertible_augmentations"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-43"><a href="#cb11-43"></a>        <span class="dt">"n_invertible"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb11-44"><a href="#cb11-44"></a>        </span>
<span id="cb11-45"><a href="#cb11-45"></a>        <span class="dt">"class_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-46"><a href="#cb11-46"></a>        <span class="dt">"additional_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-47"><a href="#cb11-47"></a>        <span class="dt">"patch_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-48"><a href="#cb11-48"></a>        <span class="dt">"metric"</span><span class="fu">:</span> <span class="st">"dice"</span><span class="fu">,</span></span>
<span id="cb11-49"><a href="#cb11-49"></a>        <span class="dt">"n_cross_val"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-50"><a href="#cb11-50"></a>        <span class="dt">"patch_probabilistic_oversampling"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb11-51"><a href="#cb11-51"></a>        <span class="dt">"oversampling_probability"</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span></span>
<span id="cb11-52"><a href="#cb11-52"></a>        <span class="dt">"test_train_validation"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb11-53"><a href="#cb11-53"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">6</span><span class="ot">,</span></span>
<span id="cb11-54"><a href="#cb11-54"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span><span class="ot">,</span></span>
<span id="cb11-55"><a href="#cb11-55"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb11-56"><a href="#cb11-56"></a>        <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb11-57"><a href="#cb11-57"></a>        <span class="dt">"shuffle"</span><span class="fu">:</span> <span class="kw">false</span></span>
<span id="cb11-58"><a href="#cb11-58"></a>    <span class="fu">}</span></span>
<span id="cb11-59"><a href="#cb11-59"></a><span class="fu">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Comments:<br> The current configuration is loaded as a dictionary, which simplifies access and modification. This setup presents a strong foundation for integrating automated search algorithms for hyperparameter tuning, enabling more efficient model optimization.<br> The configuration structure could be reorganized and re-named to improve readability, making it easier for users to locate and adjust specific parameters.</p>
</section>
<section id="visualization-of-algorithm-outputs" class="level2">
<h2 class="anchored" data-anchor-id="visualization-of-algorithm-outputs">Visualization of algorithm outputs ⚠️</h2>
<p>This module provides basic visualization functionality by saving output masks and images first to MedImage format and then to Nifti format. The <code>create_nii_from_medimage</code> function from MedImage.jl generates Nifti files, which can be loaded into MedEye3D for 3D visualization.</p>
<p>Comments:<br> Integrating this visualization module more fully with the pipeline could eliminate unnecessary steps. By automatically loading output masks and images as raw data into MedEye3D for 3D visualization and supporting a more efficient end-to-end workflow.</p>
</section>
<section id="k-fold-cross-validation-functionality" class="level2">
<h2 class="anchored" data-anchor-id="k-fold-cross-validation-functionality">K-fold cross-validation functionality ✅</h2>
<p>K-fold cross-validation is implemented to evaluate model performance more robustly. The data is split into multiple folds, with each fold serving as a validation set once, while the others form the training set. This functionality provides a better assessment of model performance across different subsets of the data.</p>
<details>
<summary>
K-fold cross-validation functionality:
</summary>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">...</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  tstate <span class="op">=</span> <span class="fu">initialize_train_state</span>(rng, model, optimizer)</span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="cf">if</span> config[<span class="st">"learning"</span>][<span class="st">"n_cross_val"</span>]</span>
<span id="cb12-4"><a href="#cb12-4"></a>      n_folds <span class="op">=</span> config[<span class="st">"learning"</span>][<span class="st">"n_folds"</span>]</span>
<span id="cb12-5"><a href="#cb12-5"></a>      all_tstate <span class="op">=</span> []</span>
<span id="cb12-6"><a href="#cb12-6"></a>      combined_indices <span class="op">=</span> [indices_dict[<span class="st">"train"</span>]; indices_dict[<span class="st">"validation"</span>]]</span>
<span id="cb12-7"><a href="#cb12-7"></a>      shuffled_indices <span class="op">=</span> <span class="fu">shuffle</span>(rng, combined_indices)</span>
<span id="cb12-8"><a href="#cb12-8"></a>      <span class="cf">for</span> fold <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n_folds</span>
<span id="cb12-9"><a href="#cb12-9"></a>          <span class="fu">println</span>(<span class="st">"Starting fold </span><span class="sc">$</span>fold<span class="st">/</span><span class="sc">$</span>n_folds<span class="st">"</span>)</span>
<span id="cb12-10"><a href="#cb12-10"></a>          train_groups, validation_groups <span class="op">=</span> <span class="fu">k_fold_split</span>(combined_indices, n_folds, fold, rng)</span>
<span id="cb12-11"><a href="#cb12-11"></a>          </span>
<span id="cb12-12"><a href="#cb12-12"></a>          tstate <span class="op">=</span> <span class="fu">initialize_train_state</span>(rng, model, optimizer)</span>
<span id="cb12-13"><a href="#cb12-13"></a>          final_tstate <span class="op">=</span> <span class="fu">epoch_loop</span>(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span>
<span id="cb12-14"><a href="#cb12-14"></a>          </span>
<span id="cb12-15"><a href="#cb12-15"></a>          <span class="fu">push!</span>(all_tstate, final_tstate)</span>
<span id="cb12-16"><a href="#cb12-16"></a>      <span class="cf">end</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>  <span class="cf">else</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>      final_tstate <span class="op">=</span> <span class="fu">epoch_loop</span>(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span>
<span id="cb12-19"><a href="#cb12-19"></a>  <span class="cf">end</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>  <span class="cf">return</span> final_tstate</span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="op">...</span>  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>The <code>k_fold_split</code> function organizes the indices for each fold, ensuring comprehensive coverage of the dataset during training.</p>
<details>
<summary>
k_fold_split
</summary>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">function</span> <span class="fu">k_fold_split</span>(data, n_folds, current_fold)</span>
<span id="cb13-2"><a href="#cb13-2"></a>    fold_size <span class="op">=</span> <span class="fu">length</span>(data) <span class="op">÷</span> n_folds</span>
<span id="cb13-3"><a href="#cb13-3"></a>    validation_start <span class="op">=</span> (current_fold <span class="op">-</span> <span class="fl">1</span>) <span class="op">*</span> fold_size <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    validation_end <span class="op">=</span> validation_start <span class="op">+</span> fold_size <span class="op">-</span> <span class="fl">1</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    validation_indices <span class="op">=</span> data[validation_start<span class="op">:</span>validation_end]</span>
<span id="cb13-6"><a href="#cb13-6"></a>    train_indices <span class="op">=</span> [data[<span class="fl">1</span><span class="op">:</span>validation_start<span class="op">-</span><span class="fl">1</span>]; data[validation_end<span class="op">+</span><span class="fl">1</span><span class="op">:</span><span class="kw">end</span>]]</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="cf">return</span> train_indices, validation_indices</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
</section>
<section id="conclusions-and-future-development" class="level1">
<h1>Conclusions and Future Development</h1>
<p>I have successfully established a foundation for a medical imaging pipeline, addressing significant challenges in data handling, model training, and augmentation integration. The integration of dataset-wide functions has significantly enhanced the reproducibility and handling of batched data with GPU support enabling scalability of experiments, making it easier for researchers and practitioners to produce better results.</p>
</section>
<section id="future-development" class="level1">
<h1>Future Development</h1>
<p>As we look to the future, there are several areas where MedPipe3D can be expanded and improved to better serve the medical AI community. These include:</p>
<section id="necessary-enhancements" class="level2">
<h2 class="anchored" data-anchor-id="necessary-enhancements">Necessary Enhancements</h2>
<p>Comprehensive Logging: Develop detailed logging mechanisms that capture a wide range of events, including system statuses, model performance metrics, and user activities, to facilitate debugging and system optimization. This is currently executed as a simple <code>println</code> function.</p>
<p>TensorBoard Integration: Implement an interface for TensorBoard to allow users to visualize training dynamics in real time, providing insights into model behavior and performance trends.</p>
<p>Error and Warning Logs: Introduce advanced error and warning logging capabilities to alert users of potential issues before they affect the pipeline’s performance, ensuring smoother operations and maintenance.</p>
<p>Automated Visualization: Integrate MedEye3D directly into MedPipe3D to enable automated visualization of outputs, such as segmentation masks or other relevant medical imaging features. This feature would provide users with real-time visual feedback on model performance and data quality. Code-Level Documentation: Due to needed changes in the fundamental structure of the pipeline in the final phase of the project, it is necessary to reevaluate all documentation.</p>
<p>Official JuliaHealth Documentation: Extend the documentation efforts to include official entries on juliahealth.org, providing a centralized and authoritative resource for users seeking to learn more about MedPipe3D and its capabilities with examples shown</p>
</section>
<section id="potential-enhancements" class="level2">
<h2 class="anchored" data-anchor-id="potential-enhancements">Potential Enhancements</h2>
<p>GPU support for interpolation will allow for significant acceleration of such functions as Scale transform, Simulate, Low-resolution transform, Elastic deformation transform, and Resampling spacing.</p>
<p>Add more reversible augmentations to test time.</p>
<p>Calculating the average of the edges of the picture: checking the type of photo and calculating more correctly on this basis</p>
<p>Elastic deformation transforms with the simulation of different tissue elasticities.</p>
</section>
</section>
<section id="acknowledgments" class="level1">
<h1>Acknowledgments 🙇‍♂️</h1>
<p>I would like to express my deepest gratitude to my mentor Dr.&nbsp;<a href="https://www.linkedin.com/in/jakub-mitura-7b2013151/">Jakub Mitura</a> for his invaluable guidance and support throughout this project. His expertise and encouragement were instrumental in overcoming challenges and achieving project milestones.</p>


<!-- -->

</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{zubik2024,
  author = {Zubik, Jan},
  title = {GSoC ’24: {Adding} Dataset-Wide Functions and Integrations of
    Augmentations},
  date = {2024-11-03},
  url = {https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-zubik2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Zubik, Jan. 2024. <span>“GSoC ’24: Adding Dataset-Wide Functions and
Integrations of Augmentations.”</span> November 3, 2024. <a href="https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html">https://juliahealth.org/JuliaHealthBlog/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/juliahealth\.org\/JuliaHealthBlog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="JuliaHealth/JuliaHealthBlog" issue-term="title" theme="github-dark" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb14" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">---</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="an">title:</span><span class="co"> "GSoC '24: Adding dataset-wide functions and integrations of augmentations"</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="an">description:</span><span class="co"> "MedPipe3D - Medical segmentation pipeline with dataset-wide functions and augmentations."</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="an">author:</span><span class="co"> "Jan Zubik"</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="an">date:</span><span class="co"> "11/03/2024"</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="an">engine:</span><span class="co"> julia</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="an">categories:</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">  - gsoc</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">  - AI/ML</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="co">  - imaging</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="co">  - gpu</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="co">  - analysis</span></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="co">---</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="fu"># 📝🩻📎📉 ➡️ 🗃️📚♻️🧑‍🏫 ➡️ 🤖👁️📈 ➡️ ❤️‍🩹  </span></span>
<span id="cb14-17"><a href="#cb14-17"></a>*These emoticons may resemble **hieroglyphics**, but very soon you will realize that they **mean more than 1000s** of lines of code.*</span>
<span id="cb14-18"><a href="#cb14-18"></a></span>
<span id="cb14-19"><a href="#cb14-19"></a>&lt;details&gt;</span>
<span id="cb14-20"><a href="#cb14-20"></a>  &lt;summary&gt;Description of the emojis used in the title&lt;/summary&gt;</span>
<span id="cb14-21"><a href="#cb14-21"></a>  &lt;ul&gt;</span>
<span id="cb14-22"><a href="#cb14-22"></a>    &lt;li&gt;📝 **Action Plan**: A clear, structured plan that guides each step of the MedPipe3D pipeline.&lt;/li&gt;</span>
<span id="cb14-23"><a href="#cb14-23"></a>    &lt;li&gt;🩻 **3D Medical Images**: Medical imaging data, such as MRI scans in Nifti format.&lt;/li&gt;</span>
<span id="cb14-24"><a href="#cb14-24"></a>    &lt;li&gt;📎 **AI Model**: The initial AI model that will be trained and refined within the pipeline.&lt;/li&gt;</span>
<span id="cb14-25"><a href="#cb14-25"></a>    &lt;li&gt;📉 **Loss Function**: A function that measures the model’s performance during training, guiding the optimization process.&lt;/li&gt;    </span>
<span id="cb14-26"><a href="#cb14-26"></a>    &lt;li&gt;🗃️ **Data Loading**: Preparation and loading of data and metadata into HDF5 format.&lt;/li&gt;</span>
<span id="cb14-27"><a href="#cb14-27"></a>    &lt;li&gt;📚 **Data Splitting**: Dividing data into training, validation, and test sets.&lt;/li&gt;</span>
<span id="cb14-28"><a href="#cb14-28"></a>    &lt;li&gt;♻️ **Data Augmentation**: Increasing data variability through augmentation.&lt;/li&gt;</span>
<span id="cb14-29"><a href="#cb14-29"></a>    &lt;li&gt;🧑‍🏫 **AI Training**: Using Lux.jl framework to train the AI model.&lt;/li&gt;</span>
<span id="cb14-30"><a href="#cb14-30"></a>    &lt;li&gt;🤖 **Model**: The trained AI model that can perform tasks like segmentation on medical images.&lt;/li&gt;</span>
<span id="cb14-31"><a href="#cb14-31"></a>    &lt;li&gt;👁️ **Data for Visualization**: Output data, such as masks and segmentations.&lt;/li&gt;</span>
<span id="cb14-32"><a href="#cb14-32"></a>    &lt;li&gt;📈 **Performance Logs**: Logs and metrics documenting the AI's performance.&lt;/li&gt;</span>
<span id="cb14-33"><a href="#cb14-33"></a>    &lt;li&gt;❤️‍🩹 **Purpose of MedPipe3D**&lt;/li&gt;</span>
<span id="cb14-34"><a href="#cb14-34"></a>  &lt;/ul&gt;</span>
<span id="cb14-35"><a href="#cb14-35"></a></span>
<span id="cb14-36"><a href="#cb14-36"></a>&lt;/details&gt;</span>
<span id="cb14-37"><a href="#cb14-37"></a></span>
<span id="cb14-38"><a href="#cb14-38"></a>&lt;hr&gt;</span>
<span id="cb14-39"><a href="#cb14-39"></a>In this post, I'd like to summarize what I did this summer and everything I learned along the way, rebuilding the MedPipe3D medical imaging pipeline. I will not start typically, but so that anyone even a novice can visualize what this project has achieved, while the latter part is intended for more experienced readers. It will be easiest to divide it into 4 steps separated by ➡️ in the title above. Each emoji stands for a different piece of pipeliner and will be described below.</span>
<span id="cb14-40"><a href="#cb14-40"></a></span>
<span id="cb14-41"><a href="#cb14-41"></a>📝🩻📎📉 **What we need from the user**</span>
<span id="cb14-42"><a href="#cb14-42"></a></span>
<span id="cb14-43"><a href="#cb14-43"></a>MedPipe3D requires four essential inputs from the user to get started: a clear action plan 📝, 3D medical images like MRI scans 🩻, an AI model 📎, and a loss function 📉.</span>
<span id="cb14-44"><a href="#cb14-44"></a></span>
<span id="cb14-45"><a href="#cb14-45"></a>🗃️📚♻️🧑‍🏫 **The Pipeline essential AI manufacturing line**</span>
<span id="cb14-46"><a href="#cb14-46"></a></span>
<span id="cb14-47"><a href="#cb14-47"></a>Following the plan 📝, MedPipe3D loads data, pre-processes, and organizes it 🗃️. Allowing data to be easily split 📚, and efficiently augmented ♻️ in many ways for learning AI 🧑‍🏫 model effectively. In the end, performing testing and post-processing for better determination of AI skills.  </span>
<span id="cb14-48"><a href="#cb14-48"></a>It's designed to transform raw medical data into a format that your AI can learn from, segmenting meaningful patterns and structures.</span>
<span id="cb14-49"><a href="#cb14-49"></a></span>
<span id="cb14-50"><a href="#cb14-50"></a>🤖👁️📈 **Results and Insights**</span>
<span id="cb14-51"><a href="#cb14-51"></a></span>
<span id="cb14-52"><a href="#cb14-52"></a>MedPipe3D is a tool for researchers and for that, it cannot do without analysis, testing, and evaluation. The result of the pipeline is a model 🤖 as well as data 👁️ and logs 📈 needed in MedEval3D that are ready for visualization and further analysis with MedEye3D. In a nutshell, it makes visualizing results easy, tumor locations or other medical features directly as masks on the scans.</span>
<span id="cb14-53"><a href="#cb14-53"></a></span>
<span id="cb14-54"><a href="#cb14-54"></a>❤️‍🩹 **Purpose-Driven Technology**</span>
<span id="cb14-55"><a href="#cb14-55"></a></span>
<span id="cb14-56"><a href="#cb14-56"></a>MedPipe3D's mission goes beyond technology. It's about providing the tools to create AIs that support healthcare professionals in making faster, more accurate decisions, with the ultimate goal of saving lives.</span>
<span id="cb14-57"><a href="#cb14-57"></a></span>
<span id="cb14-58"><a href="#cb14-58"></a>This four-part journey captures the heart of the MedPipe3D toolkit for advancing medical AI, from raw data to life-saving insight.</span>
<span id="cb14-59"><a href="#cb14-59"></a></span>
<span id="cb14-60"><a href="#cb14-60"></a><span class="fu">## Introduction</span></span>
<span id="cb14-61"><a href="#cb14-61"></a></span>
<span id="cb14-62"><a href="#cb14-62"></a>**MedPipe3D** is a framework created from hundreds of hours over summer vacation, thousands of lines of code, hundreds of mistakes, and most importantly the guidance of my mentor and author of all of these libraries Dr. <span class="co">[</span><span class="ot">Jakub Mitura</span><span class="co">](https://www.linkedin.com/in/jakub-mitura-7b2013151/)</span>.</span>
<span id="cb14-63"><a href="#cb14-63"></a>At its core, MedPipe3D combines sophisticated data handling from **MedImage** thanks to the hard work of [Divyansh Goyal](https://www.linkedin.com/in/divyansh-goyal-34654b200/). Newly developed pipeline for model training, validation, and testing with existing **MedEval3D**, and result visualization with **MedEye3D**.</span>
<span id="cb14-64"><a href="#cb14-64"></a>Unfortunately, not all of the project's goals have been fully achieved, and thereby there is one section ➡️ too many. Hopefully not for long. My name is <span class="co">[</span><span class="ot">Jan Zubik</span><span class="co">](https://www.linkedin.com/in/janzubik/)</span>, and I wrote this entire library from scratch, which is currently my most complex project.</span>
<span id="cb14-65"><a href="#cb14-65"></a></span>
<span id="cb14-66"><a href="#cb14-66"></a>If you are a data scientist, programmer, or code enthusiast, I invite you to read the next section where I go into detail and present **version 1** of this tool in detail.</span>
<span id="cb14-67"><a href="#cb14-67"></a></span>
<span id="cb14-68"><a href="#cb14-68"></a>I'm a 3rd-year student of BSc in Data Science and Machine Learning, I know that many things can be done better, expanded, debugged, and optimized. Now it just works, **but don't hesitate to write to me personally** on <span class="co">[</span><span class="ot">LinkedIn</span><span class="co">](https://www.linkedin.com/in/janzubik/)</span>, <span class="co">[</span><span class="ot">Julia's Slack</span><span class="co">](https://julialang.slack.com/team/U06L685B6TD)</span> or <span class="co">[</span><span class="ot">GitHub</span><span class="co">](https://github.com/JanZubik)</span>!</span>
<span id="cb14-69"><a href="#cb14-69"></a>With your comments, and direct critique **you will help me** to be a better programmer and one day MedPipe3D will contribute in a tiny way to save someone's life!</span>
<span id="cb14-70"><a href="#cb14-70"></a></span>
<span id="cb14-71"><a href="#cb14-71"></a>Exact work from the Google Summer of Code project you will find in <span class="co">[</span><span class="ot">GitHub the repository.</span><span class="co">](https://github.com/JuliaHealth/MedPipe3D.jl/tree/GSoC-'24-MedPipe3D)</span></span>
<span id="cb14-72"><a href="#cb14-72"></a></span>
<span id="cb14-73"><a href="#cb14-73"></a></span>
<span id="cb14-74"><a href="#cb14-74"></a><span class="fu"># Project Goals</span></span>
<span id="cb14-75"><a href="#cb14-75"></a></span>
<span id="cb14-76"><a href="#cb14-76"></a>The primary goal was to develop MedPipe3D and enhance MedImage, a Julia package designed to streamline the process of GPU-accelerated medical image segmentation. The project aimed to merge existing libraries—MedEye3D, MedEval3D, and MedImage—into a cohesive pipeline that facilitates advanced data handling, preprocessing, augmentation, model training, validation, testing with post-processing and visualization for medical imaging applications.</span>
<span id="cb14-77"><a href="#cb14-77"></a></span>
<span id="cb14-78"><a href="#cb14-78"></a></span>
<span id="cb14-79"><a href="#cb14-79"></a></span>
<span id="cb14-80"><a href="#cb14-80"></a><span class="fu"># Tasks</span></span>
<span id="cb14-81"><a href="#cb14-81"></a></span>
<span id="cb14-82"><a href="#cb14-82"></a><span class="ss">- </span>🆙 - Fully finished, with great potential for further development</span>
<span id="cb14-83"><a href="#cb14-83"></a><span class="ss">- </span>✅ - Fully completed</span>
<span id="cb14-84"><a href="#cb14-84"></a><span class="ss">- </span>⚠️ - Partially uncompleted</span>
<span id="cb14-85"><a href="#cb14-85"></a><span class="ss">- </span>❌ - Unreached</span>
<span id="cb14-86"><a href="#cb14-86"></a></span>
<span id="cb14-87"><a href="#cb14-87"></a>Full list of all major parts and minor tasks (all tasks set up in the original GSOC plan were completed at least minimum level, and many additional improvements above minimum were implemented)</span>
<span id="cb14-88"><a href="#cb14-88"></a>&lt;details&gt;</span>
<span id="cb14-89"><a href="#cb14-89"></a></span>
<span id="cb14-90"><a href="#cb14-90"></a><span class="ss">1. </span>**Helpful functions to support the MedImage format ✅**</span>
<span id="cb14-91"><a href="#cb14-91"></a><span class="ss">  - </span>Debugging rotations ✅</span>
<span id="cb14-92"><a href="#cb14-92"></a><span class="ss">  - </span>Crop MedImage or 3D array ✅</span>
<span id="cb14-93"><a href="#cb14-93"></a><span class="ss">  - </span>Pad MedImage or 3D array ✅</span>
<span id="cb14-94"><a href="#cb14-94"></a><span class="ss">  - </span>Pad with edge values ✅</span>
<span id="cb14-95"><a href="#cb14-95"></a><span class="ss">  - </span>Calculating the average of the edges of the picture 🆙</span>
<span id="cb14-96"><a href="#cb14-96"></a></span>
<span id="cb14-97"><a href="#cb14-97"></a><span class="ss">2. </span>**Integrate Augmentations for Medical Data ✅**</span>
<span id="cb14-98"><a href="#cb14-98"></a><span class="ss">  - </span>Brightness transform ✅</span>
<span id="cb14-99"><a href="#cb14-99"></a><span class="ss">  - </span>Contrast augmentation transform ✅</span>
<span id="cb14-100"><a href="#cb14-100"></a><span class="ss">  - </span>Gamma Transform ✅</span>
<span id="cb14-101"><a href="#cb14-101"></a><span class="ss">  - </span>Gaussian noise transform ✅</span>
<span id="cb14-102"><a href="#cb14-102"></a><span class="ss">  - </span>Rician noise transform ✅</span>
<span id="cb14-103"><a href="#cb14-103"></a><span class="ss">  - </span>Mirror transform ✅</span>
<span id="cb14-104"><a href="#cb14-104"></a><span class="ss">  - </span>Scale transform 🆙</span>
<span id="cb14-105"><a href="#cb14-105"></a><span class="ss">  - </span>Gaussian blur transform ✅</span>
<span id="cb14-106"><a href="#cb14-106"></a><span class="ss">  - </span>Simulate low-resolution transform 🆙</span>
<span id="cb14-107"><a href="#cb14-107"></a><span class="ss">  - </span>Elastic deformation transform 🆙</span>
<span id="cb14-108"><a href="#cb14-108"></a></span>
<span id="cb14-109"><a href="#cb14-109"></a><span class="ss">3. </span>**Develop a Pipeline ⚠️**</span>
<span id="cb14-110"><a href="#cb14-110"></a><span class="ss">  - </span>Structured configuration of all hyperparameters 🆙</span>
<span id="cb14-111"><a href="#cb14-111"></a><span class="ss">   - </span>Interactive creation of configuration ✅</span>
<span id="cb14-112"><a href="#cb14-112"></a><span class="ss">   - </span>Creating a structured configuration of hyperparameters in JSON 🆙</span>
<span id="cb14-113"><a href="#cb14-113"></a><span class="ss">  - </span>Loading data into HDF5 ✅</span>
<span id="cb14-114"><a href="#cb14-114"></a><span class="ss">    - </span>Cropping and padding to real coordinates of the main picture ✅</span>
<span id="cb14-115"><a href="#cb14-115"></a><span class="ss">    - </span>Calculate Median and Mean Spacing with resampling 🆙</span>
<span id="cb14-116"><a href="#cb14-116"></a><span class="ss">    - </span>Cropping and padding to specific or average dimensions ✅</span>
<span id="cb14-117"><a href="#cb14-117"></a><span class="ss">    - </span>Standardization and normalization ✅</span>
<span id="cb14-118"><a href="#cb14-118"></a><span class="ss">  - </span>Managing index groups (channels) for batch requirements in HDF5 ✅</span>
<span id="cb14-119"><a href="#cb14-119"></a><span class="ss">    - </span>Divide into train, validation, test specified as % ✅</span>
<span id="cb14-120"><a href="#cb14-120"></a><span class="ss">    - </span>Divide with a specific division specified in JSON ✅</span>
<span id="cb14-121"><a href="#cb14-121"></a><span class="ss">    - </span>Equal distribution when there are multiple classes ✅</span>
<span id="cb14-122"><a href="#cb14-122"></a><span class="ss">  - </span>Extracting data and creating 5-dimensional tensors for batched learning ✅</span>
<span id="cb14-123"><a href="#cb14-123"></a><span class="ss">    - </span>Hole images data loading ✅</span>
<span id="cb14-124"><a href="#cb14-124"></a><span class="ss">    - </span>Patch-based data loading with probabilistic oversampling ✅</span>
<span id="cb14-125"><a href="#cb14-125"></a><span class="ss">  - </span>Obtaining the necessary elements for learning ✅</span>
<span id="cb14-126"><a href="#cb14-126"></a><span class="ss">    - </span>Get optimizer, loss function, and performance metrics ✅</span>
<span id="cb14-127"><a href="#cb14-127"></a><span class="ss">  - </span>Apply augmentations ✅</span>
<span id="cb14-128"><a href="#cb14-128"></a><span class="ss">  - </span>Train ✅</span>
<span id="cb14-129"><a href="#cb14-129"></a><span class="ss">    - </span>Initializing model ✅</span>
<span id="cb14-130"><a href="#cb14-130"></a><span class="ss">    - </span>The learning epoch ✅</span>
<span id="cb14-131"><a href="#cb14-131"></a><span class="ss">    - </span>Epoch with early stopping functionality ✅</span>
<span id="cb14-132"><a href="#cb14-132"></a><span class="ss">  - </span>Inferring ✅</span>
<span id="cb14-133"><a href="#cb14-133"></a><span class="ss">  - </span>Validation ✅</span>
<span id="cb14-134"><a href="#cb14-134"></a><span class="ss">    - </span>Evaluate metric ✅</span>
<span id="cb14-135"><a href="#cb14-135"></a><span class="ss">    - </span>Evaluate validation loss ✅</span>
<span id="cb14-136"><a href="#cb14-136"></a><span class="ss">    - </span>Validation with largest connected component✅</span>
<span id="cb14-137"><a href="#cb14-137"></a><span class="ss">  - </span>Testing ✅</span>
<span id="cb14-138"><a href="#cb14-138"></a><span class="ss">    - </span>Evaluate test set ✅</span>
<span id="cb14-139"><a href="#cb14-139"></a><span class="ss">    - </span>Invertible augmentations evaluation ✅</span>
<span id="cb14-140"><a href="#cb14-140"></a><span class="ss">    - </span>Patch-based invertible augmentations evaluation ✅</span>
<span id="cb14-141"><a href="#cb14-141"></a><span class="ss">  - </span>Logging ⚠️</span>
<span id="cb14-142"><a href="#cb14-142"></a><span class="ss">    - </span>Returning the necessary results ⚠️</span>
<span id="cb14-143"><a href="#cb14-143"></a><span class="ss">    - </span>Logging connection to TensorBoard ❌</span>
<span id="cb14-144"><a href="#cb14-144"></a><span class="ss">    - </span>Logging errors and warnings ❌</span>
<span id="cb14-145"><a href="#cb14-145"></a><span class="ss">  - </span>Visualization ⚠️</span>
<span id="cb14-146"><a href="#cb14-146"></a><span class="ss">    - </span>Returning data in Nifti format ✅</span>
<span id="cb14-147"><a href="#cb14-147"></a><span class="ss">    - </span>Automated visualization in MedEye3D ❌</span>
<span id="cb14-148"><a href="#cb14-148"></a></span>
<span id="cb14-149"><a href="#cb14-149"></a><span class="ss">4. </span>**Optimize Performance with GPU Acceleration**</span>
<span id="cb14-150"><a href="#cb14-150"></a><span class="ss">   - </span>Augmentations ✅</span>
<span id="cb14-151"><a href="#cb14-151"></a><span class="ss">   - </span>Learning, Validation, Testing ✅</span>
<span id="cb14-152"><a href="#cb14-152"></a><span class="ss">   - </span>Largest connected component ✅</span>
<span id="cb14-153"><a href="#cb14-153"></a></span>
<span id="cb14-154"><a href="#cb14-154"></a><span class="ss">5. </span>**Documentation ⚠️**</span>
<span id="cb14-155"><a href="#cb14-155"></a><span class="ss">   - </span>Comments in important places in the code ⚠️</span>
<span id="cb14-156"><a href="#cb14-156"></a><span class="ss">   - </span>Documentation of the function ⚠️</span>
<span id="cb14-157"><a href="#cb14-157"></a><span class="ss">   - </span>Read me ⚠️</span>
<span id="cb14-158"><a href="#cb14-158"></a><span class="ss">   - </span>Documentation on juliahealth.org ❌</span>
<span id="cb14-159"><a href="#cb14-159"></a></span>
<span id="cb14-160"><a href="#cb14-160"></a>&lt;/details&gt;</span>
<span id="cb14-161"><a href="#cb14-161"></a></span>
<span id="cb14-162"><a href="#cb14-162"></a><span class="fu">## Integrate augmentations for medical data 🆙</span></span>
<span id="cb14-163"><a href="#cb14-163"></a>Augmenting medical data is a crucial step for enhancing model robustness, especially given the variations in imaging conditions and patient anatomy. </span>
<span id="cb14-164"><a href="#cb14-164"></a></span>
<span id="cb14-165"><a href="#cb14-165"></a><span class="ss">- </span>This pipeline currently supports multiple augmentation techniques:</span>
<span id="cb14-166"><a href="#cb14-166"></a><span class="ss">  - </span>Brightness transform ✅</span>
<span id="cb14-167"><a href="#cb14-167"></a><span class="ss">  - </span>Contrast augmentation transform ✅</span>
<span id="cb14-168"><a href="#cb14-168"></a><span class="ss">  - </span>Gamma Transform ✅</span>
<span id="cb14-169"><a href="#cb14-169"></a><span class="ss">  - </span>Gaussian noise transform ✅</span>
<span id="cb14-170"><a href="#cb14-170"></a><span class="ss">  - </span>Rician noise transform ✅</span>
<span id="cb14-171"><a href="#cb14-171"></a><span class="ss">  - </span>Mirror transform ✅</span>
<span id="cb14-172"><a href="#cb14-172"></a><span class="ss">  - </span>Scale transform 🆙</span>
<span id="cb14-173"><a href="#cb14-173"></a><span class="ss">  - </span>Gaussian blur transform ✅</span>
<span id="cb14-174"><a href="#cb14-174"></a><span class="ss">  - </span>Simulate low-resolution transform 🆙</span>
<span id="cb14-175"><a href="#cb14-175"></a><span class="ss">  - </span>Elastic deformation transform 🆙</span>
<span id="cb14-176"><a href="#cb14-176"></a></span>
<span id="cb14-177"><a href="#cb14-177"></a>Which have been fully integrated. Each of these methods helps the model generalize better by simulating diverse imaging scenarios.</span>
<span id="cb14-178"><a href="#cb14-178"></a></span>
<span id="cb14-179"><a href="#cb14-179"></a><span class="al">![](./Augmentations.png)</span></span>
<span id="cb14-180"><a href="#cb14-180"></a></span>
<span id="cb14-181"><a href="#cb14-181"></a>Comments:</span>
<span id="cb14-182"><a href="#cb14-182"></a></span>
<span id="cb14-183"><a href="#cb14-183"></a>Augmentations such as scaling, and low-resolution simulation use interpolation that is not yet GPU-accelerated.</span>
<span id="cb14-184"><a href="#cb14-184"></a></span>
<span id="cb14-185"><a href="#cb14-185"></a>Elastic deformation with simulation of different tissue elasticities is a potential development opportunity that would further improve the model's adaptability by mimicking more complex variations found in medical imaging.</span>
<span id="cb14-186"><a href="#cb14-186"></a></span>
<span id="cb14-187"><a href="#cb14-187"></a><span class="fu">## Invertible augmentations and support test time augmentations 🆙</span></span>
<span id="cb14-188"><a href="#cb14-188"></a>This section focuses on the ability to apply reversible augmentations to test data, allowing the model to be evaluated with different transformations. Only rotation is available at this time. The function <span class="in">`evaluate_patches`</span> performs this evaluation by applying specified augmentations, dividing the test data into patches, and reconstructing the full image from the patches. During testing, one can choose to use of largest connected component post-processing. Metrics are calculated and results are saved for analysis.</span>
<span id="cb14-189"><a href="#cb14-189"></a></span>
<span id="cb14-190"><a href="#cb14-190"></a>&lt;details&gt;</span>
<span id="cb14-191"><a href="#cb14-191"></a>&lt;summary&gt;evaluate_test:&lt;/summary&gt;</span>
<span id="cb14-192"><a href="#cb14-192"></a></span>
<span id="cb14-193"><a href="#cb14-193"></a><span class="in">```julia</span></span>
<span id="cb14-194"><a href="#cb14-194"></a><span class="in"># ...</span></span>
<span id="cb14-195"><a href="#cb14-195"></a><span class="in">for test_group in test_groups</span></span>
<span id="cb14-196"><a href="#cb14-196"></a><span class="in">    test_data, test_label, attributes = fetch_and_preprocess_data([test_group], h5, config)</span></span>
<span id="cb14-197"><a href="#cb14-197"></a><span class="in">    results, test_metrics = evaluate_patches(test_data, test_label,  tstate, model, config)</span></span>
<span id="cb14-198"><a href="#cb14-198"></a><span class="in">    y_pred, metr = process_results(results, test_metrics, config)</span></span>
<span id="cb14-199"><a href="#cb14-199"></a><span class="in">    save_results(y_pred, attributes, config)</span></span>
<span id="cb14-200"><a href="#cb14-200"></a><span class="in">    push!(all_test_metrics, metr)</span></span>
<span id="cb14-201"><a href="#cb14-201"></a><span class="in">end</span></span>
<span id="cb14-202"><a href="#cb14-202"></a><span class="in"># ...</span></span>
<span id="cb14-203"><a href="#cb14-203"></a><span class="in">```</span></span>
<span id="cb14-204"><a href="#cb14-204"></a></span>
<span id="cb14-205"><a href="#cb14-205"></a><span class="in">```julia</span></span>
<span id="cb14-206"><a href="#cb14-206"></a><span class="in">function evaluate_patches(test_data, test_label, tstate, model, config, axis, angle)</span></span>
<span id="cb14-207"><a href="#cb14-207"></a><span class="in">    println("Evaluating patches...")</span></span>
<span id="cb14-208"><a href="#cb14-208"></a><span class="in">    results = []</span></span>
<span id="cb14-209"><a href="#cb14-209"></a><span class="in">    test_metrics = []</span></span>
<span id="cb14-210"><a href="#cb14-210"></a><span class="in">    tstates = [tstate]</span></span>
<span id="cb14-211"><a href="#cb14-211"></a><span class="in">    test_time_augs = []</span></span>
<span id="cb14-212"><a href="#cb14-212"></a></span>
<span id="cb14-213"><a href="#cb14-213"></a><span class="in">    for i in config["learning"]["n_invertible"]</span></span>
<span id="cb14-214"><a href="#cb14-214"></a><span class="in">        data = rotate_mi(test_data, axis, angle)</span></span>
<span id="cb14-215"><a href="#cb14-215"></a><span class="in">        for tstate_curr in tstates</span></span>
<span id="cb14-216"><a href="#cb14-216"></a><span class="in">            patch_results = []</span></span>
<span id="cb14-217"><a href="#cb14-217"></a><span class="in">            patch_size = Tuple(config["learning"]["patch_size"])</span></span>
<span id="cb14-218"><a href="#cb14-218"></a><span class="in">            idx_and_patches, paded_data_size = divide_into_patches(test_data, patch_size)</span></span>
<span id="cb14-219"><a href="#cb14-219"></a><span class="in">            coordinates = [patch[1] for patch in idx_and_patches]</span></span>
<span id="cb14-220"><a href="#cb14-220"></a><span class="in">            patch_data = [patch[2] for patch in idx_and_patches]</span></span>
<span id="cb14-221"><a href="#cb14-221"></a><span class="in">            for patch in patch_data</span></span>
<span id="cb14-222"><a href="#cb14-222"></a><span class="in">                y_pred_patch, _ = infer_model(tstate_curr, model, patch)</span></span>
<span id="cb14-223"><a href="#cb14-223"></a><span class="in">                push!(patch_results, y_pred_patch)</span></span>
<span id="cb14-224"><a href="#cb14-224"></a><span class="in">            end</span></span>
<span id="cb14-225"><a href="#cb14-225"></a><span class="in">            idx_and_y_pred_patch = zip(coordinates, patch_results)</span></span>
<span id="cb14-226"><a href="#cb14-226"></a><span class="in">            y_pred = recreate_image_from_patches(idx_and_y_pred_patch, paded_data_size, patch_size, size(test_data))</span></span>
<span id="cb14-227"><a href="#cb14-227"></a><span class="in">            if config["learning"]["largest_connected_component"]</span></span>
<span id="cb14-228"><a href="#cb14-228"></a><span class="in">                y_pred = largest_connected_component(y_pred, config["learning"]["n_lcc"])</span></span>
<span id="cb14-229"><a href="#cb14-229"></a><span class="in">            end</span></span>
<span id="cb14-230"><a href="#cb14-230"></a><span class="in">            metr = evaluate_metric(y_pred, test_label, config["learning"]["metric"])</span></span>
<span id="cb14-231"><a href="#cb14-231"></a><span class="in">            push!(test_metrics, metr)</span></span>
<span id="cb14-232"><a href="#cb14-232"></a><span class="in">        end</span></span>
<span id="cb14-233"><a href="#cb14-233"></a><span class="in">    end</span></span>
<span id="cb14-234"><a href="#cb14-234"></a><span class="in">    return results, test_metrics</span></span>
<span id="cb14-235"><a href="#cb14-235"></a><span class="in">end</span></span>
<span id="cb14-236"><a href="#cb14-236"></a><span class="in">```</span></span>
<span id="cb14-237"><a href="#cb14-237"></a></span>
<span id="cb14-238"><a href="#cb14-238"></a><span class="in">```julia</span></span>
<span id="cb14-239"><a href="#cb14-239"></a><span class="in">function divide_into_patches(image::AbstractArray{T, 5}, patch_size::Tuple{Int, Int, Int}) where T</span></span>
<span id="cb14-240"><a href="#cb14-240"></a><span class="in">    println("Dividing image into patches...")</span></span>
<span id="cb14-241"><a href="#cb14-241"></a><span class="in">    println("Size of the image: ", size(image)) </span></span>
<span id="cb14-242"><a href="#cb14-242"></a></span>
<span id="cb14-243"><a href="#cb14-243"></a><span class="in">    # Calculate the required padding for each dimension (W, H, D)</span></span>
<span id="cb14-244"><a href="#cb14-244"></a><span class="in">    pad_size = (</span></span>
<span id="cb14-245"><a href="#cb14-245"></a><span class="in">        (size(image, 1) % patch_size[1]) != 0 ? patch_size[1] - size(image, 1) % patch_size[1] : 0,</span></span>
<span id="cb14-246"><a href="#cb14-246"></a><span class="in">        (size(image, 2) % patch_size[2]) != 0 ? patch_size[2] - size(image, 2) % patch_size[2] : 0,</span></span>
<span id="cb14-247"><a href="#cb14-247"></a><span class="in">        (size(image, 3) % patch_size[3]) != 0 ? patch_size[3] - size(image, 3) % patch_size[3] : 0</span></span>
<span id="cb14-248"><a href="#cb14-248"></a><span class="in">    )</span></span>
<span id="cb14-249"><a href="#cb14-249"></a></span>
<span id="cb14-250"><a href="#cb14-250"></a><span class="in">    # Pad the image if necessary</span></span>
<span id="cb14-251"><a href="#cb14-251"></a><span class="in">    padded_image = image</span></span>
<span id="cb14-252"><a href="#cb14-252"></a><span class="in">    if any(pad_size .&gt; 0)</span></span>
<span id="cb14-253"><a href="#cb14-253"></a><span class="in">        padded_image = crop_or_pad(image, (size(image, 1) + pad_size[1], size(image, 2) + pad_size[2], size(image, 3) + pad_size[3]))</span></span>
<span id="cb14-254"><a href="#cb14-254"></a><span class="in">    end</span></span>
<span id="cb14-255"><a href="#cb14-255"></a></span>
<span id="cb14-256"><a href="#cb14-256"></a><span class="in">    # Extract patches</span></span>
<span id="cb14-257"><a href="#cb14-257"></a><span class="in">    patches = []</span></span>
<span id="cb14-258"><a href="#cb14-258"></a><span class="in">    for x in 1:patch_size[1]:size(padded_image, 1)</span></span>
<span id="cb14-259"><a href="#cb14-259"></a><span class="in">        for y in 1:patch_size[2]:size(padded_image, 2)</span></span>
<span id="cb14-260"><a href="#cb14-260"></a><span class="in">            for z in 1:patch_size[3]:size(padded_image, 3)</span></span>
<span id="cb14-261"><a href="#cb14-261"></a><span class="in">                patch = view(</span></span>
<span id="cb14-262"><a href="#cb14-262"></a><span class="in">                    padded_image,</span></span>
<span id="cb14-263"><a href="#cb14-263"></a><span class="in">                    x:min(x+patch_size[1]-1, size(padded_image, 1)),</span></span>
<span id="cb14-264"><a href="#cb14-264"></a><span class="in">                    y:min(y+patch_size[2]-1, size(padded_image, 2)),</span></span>
<span id="cb14-265"><a href="#cb14-265"></a><span class="in">                    z:min(z+patch_size[3]-1, size(padded_image, 3)),</span></span>
<span id="cb14-266"><a href="#cb14-266"></a><span class="in">                    :,</span></span>
<span id="cb14-267"><a href="#cb14-267"></a><span class="in">                    :</span></span>
<span id="cb14-268"><a href="#cb14-268"></a><span class="in">                )</span></span>
<span id="cb14-269"><a href="#cb14-269"></a><span class="in">                push!(patches, [(x, y, z), patch])</span></span>
<span id="cb14-270"><a href="#cb14-270"></a><span class="in">            end</span></span>
<span id="cb14-271"><a href="#cb14-271"></a><span class="in">        end</span></span>
<span id="cb14-272"><a href="#cb14-272"></a><span class="in">    end</span></span>
<span id="cb14-273"><a href="#cb14-273"></a><span class="in">    println("Size of padded image: ", size(padded_image))</span></span>
<span id="cb14-274"><a href="#cb14-274"></a><span class="in">    return patches, size(padded_image)</span></span>
<span id="cb14-275"><a href="#cb14-275"></a><span class="in">end</span></span>
<span id="cb14-276"><a href="#cb14-276"></a></span>
<span id="cb14-277"><a href="#cb14-277"></a><span class="in">function recreate_image_from_patches(</span></span>
<span id="cb14-278"><a href="#cb14-278"></a><span class="in">    coords_with_patches,</span></span>
<span id="cb14-279"><a href="#cb14-279"></a><span class="in">    padded_size,</span></span>
<span id="cb14-280"><a href="#cb14-280"></a><span class="in">    patch_size,</span></span>
<span id="cb14-281"><a href="#cb14-281"></a><span class="in">    original_size</span></span>
<span id="cb14-282"><a href="#cb14-282"></a><span class="in">)</span></span>
<span id="cb14-283"><a href="#cb14-283"></a><span class="in">    println("Recreating image from patches...")</span></span>
<span id="cb14-284"><a href="#cb14-284"></a><span class="in">    reconstructed_image = zeros(Float32, padded_size...)</span></span>
<span id="cb14-285"><a href="#cb14-285"></a><span class="in">    </span></span>
<span id="cb14-286"><a href="#cb14-286"></a><span class="in">    # Place patches back into their original positions</span></span>
<span id="cb14-287"><a href="#cb14-287"></a><span class="in">    for (coords, patch) in coords_with_patches</span></span>
<span id="cb14-288"><a href="#cb14-288"></a><span class="in">        x, y, z = coords</span></span>
<span id="cb14-289"><a href="#cb14-289"></a><span class="in">        reconstructed_image[</span></span>
<span id="cb14-290"><a href="#cb14-290"></a><span class="in">            x:x+patch_size[1]-1,</span></span>
<span id="cb14-291"><a href="#cb14-291"></a><span class="in">            y:y+patch_size[2]-1,</span></span>
<span id="cb14-292"><a href="#cb14-292"></a><span class="in">            z:z+patch_size[3]-1,</span></span>
<span id="cb14-293"><a href="#cb14-293"></a><span class="in">            :,</span></span>
<span id="cb14-294"><a href="#cb14-294"></a><span class="in">            :</span></span>
<span id="cb14-295"><a href="#cb14-295"></a><span class="in">        ] = patch</span></span>
<span id="cb14-296"><a href="#cb14-296"></a><span class="in">    end</span></span>
<span id="cb14-297"><a href="#cb14-297"></a></span>
<span id="cb14-298"><a href="#cb14-298"></a><span class="in">    # Crop the reconstructed image to remove any padding</span></span>
<span id="cb14-299"><a href="#cb14-299"></a><span class="in">    final_image = reconstructed_image[</span></span>
<span id="cb14-300"><a href="#cb14-300"></a><span class="in">        1:original_size[1],</span></span>
<span id="cb14-301"><a href="#cb14-301"></a><span class="in">        1:original_size[2],</span></span>
<span id="cb14-302"><a href="#cb14-302"></a><span class="in">        1:original_size[3],</span></span>
<span id="cb14-303"><a href="#cb14-303"></a><span class="in">        :,</span></span>
<span id="cb14-304"><a href="#cb14-304"></a><span class="in">        :</span></span>
<span id="cb14-305"><a href="#cb14-305"></a><span class="in">    ]</span></span>
<span id="cb14-306"><a href="#cb14-306"></a><span class="in">    println("Size of the final image: ", size(final_image))</span></span>
<span id="cb14-307"><a href="#cb14-307"></a><span class="in">    return final_image</span></span>
<span id="cb14-308"><a href="#cb14-308"></a><span class="in">end</span></span>
<span id="cb14-309"><a href="#cb14-309"></a><span class="in">```</span></span>
<span id="cb14-310"><a href="#cb14-310"></a>&lt;/details&gt;</span>
<span id="cb14-311"><a href="#cb14-311"></a></span>
<span id="cb14-312"><a href="#cb14-312"></a>Comment:&lt;br&gt;</span>
<span id="cb14-313"><a href="#cb14-313"></a>In this section, there is significant potential to incorporate additional types of invertible augmentations.</span>
<span id="cb14-314"><a href="#cb14-314"></a></span>
<span id="cb14-315"><a href="#cb14-315"></a><span class="fu">## Patch-based data loading with probabilistic oversampling ✅</span></span>
<span id="cb14-316"><a href="#cb14-316"></a>In this section, patches are extracted using <span class="in">`extract_patch`</span> from the medical images for model training, with a probability-based method to decide between a random patch or a patch with non-zero labels.</span>
<span id="cb14-317"><a href="#cb14-317"></a>Helper functions like <span class="in">`get_random_patch`</span> and <span class="in">`get_centered_patch`</span> determine the starting indices and dimensions for the patches based on given configurations, while padding methods ensure consistency even if the patch exceeds the original image dimensions. Probabilistic oversampling, as configured, allows for more balanced and informative data sampling, which improves the model's ability to detect specific medical features.</span>
<span id="cb14-318"><a href="#cb14-318"></a></span>
<span id="cb14-319"><a href="#cb14-319"></a></span>
<span id="cb14-320"><a href="#cb14-320"></a>&lt;details&gt;</span>
<span id="cb14-321"><a href="#cb14-321"></a>&lt;summary&gt;extract_patch:&lt;/summary&gt;</span>
<span id="cb14-322"><a href="#cb14-322"></a></span>
<span id="cb14-323"><a href="#cb14-323"></a><span class="in">```julia</span></span>
<span id="cb14-324"><a href="#cb14-324"></a><span class="in">function extract_patch(image, label, patch_size, config)</span></span>
<span id="cb14-325"><a href="#cb14-325"></a><span class="in">    # Fetch the oversampling probability from the config</span></span>
<span id="cb14-326"><a href="#cb14-326"></a><span class="in">    println("Extracting patch.")</span></span>
<span id="cb14-327"><a href="#cb14-327"></a><span class="in">    oversampling_probability = config["learning"]["oversampling_probability"]</span></span>
<span id="cb14-328"><a href="#cb14-328"></a><span class="in">    # Generate a random number to decide which patch extraction method to use</span></span>
<span id="cb14-329"><a href="#cb14-329"></a><span class="in">    random_choice = rand()</span></span>
<span id="cb14-330"><a href="#cb14-330"></a></span>
<span id="cb14-331"><a href="#cb14-331"></a><span class="in">    if random_choice &lt;= oversampling_probability</span></span>
<span id="cb14-332"><a href="#cb14-332"></a><span class="in">        return extract_nonzero_patch(image, label, patch_size)</span></span>
<span id="cb14-333"><a href="#cb14-333"></a><span class="in">    else</span></span>
<span id="cb14-334"><a href="#cb14-334"></a></span>
<span id="cb14-335"><a href="#cb14-335"></a><span class="in">        return get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-336"><a href="#cb14-336"></a><span class="in">    end</span></span>
<span id="cb14-337"><a href="#cb14-337"></a><span class="in">end</span></span>
<span id="cb14-338"><a href="#cb14-338"></a><span class="in">#Helper function, in case the mask is emptyClick to apply</span></span>
<span id="cb14-339"><a href="#cb14-339"></a><span class="in">function extract_nonzero_patch(image, label, patch_size)</span></span>
<span id="cb14-340"><a href="#cb14-340"></a><span class="in">    println("Extracting a patch centered around a non-zero label value.")</span></span>
<span id="cb14-341"><a href="#cb14-341"></a><span class="in">    indices = findall(x -&gt; x != 0, label)</span></span>
<span id="cb14-342"><a href="#cb14-342"></a><span class="in">    if isempty(indices)</span></span>
<span id="cb14-343"><a href="#cb14-343"></a><span class="in">        # Fallback to random patch if no non-zero points are found</span></span>
<span id="cb14-344"><a href="#cb14-344"></a><span class="in">        return get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-345"><a href="#cb14-345"></a><span class="in">    else</span></span>
<span id="cb14-346"><a href="#cb14-346"></a><span class="in">        # Choose a random non-zero index to center the patch around</span></span>
<span id="cb14-347"><a href="#cb14-347"></a><span class="in">        center = indices[rand(1:length(indices))]</span></span>
<span id="cb14-348"><a href="#cb14-348"></a><span class="in">        return get_centered_patch(image, label, center, patch_size)</span></span>
<span id="cb14-349"><a href="#cb14-349"></a><span class="in">    end</span></span>
<span id="cb14-350"><a href="#cb14-350"></a><span class="in">end</span></span>
<span id="cb14-351"><a href="#cb14-351"></a><span class="in"># Function to get a patch centered around a specific index</span></span>
<span id="cb14-352"><a href="#cb14-352"></a><span class="in">function get_centered_patch(image, label, center, patch_size)</span></span>
<span id="cb14-353"><a href="#cb14-353"></a><span class="in">    center_coords = Tuple(center)</span></span>
<span id="cb14-354"><a href="#cb14-354"></a><span class="in">    half_patch = patch_size .÷ 2</span></span>
<span id="cb14-355"><a href="#cb14-355"></a><span class="in">    start_indices = center_coords .- half_patch</span></span>
<span id="cb14-356"><a href="#cb14-356"></a><span class="in">    end_indices = start_indices .+ patch_size .- 1</span></span>
<span id="cb14-357"><a href="#cb14-357"></a></span>
<span id="cb14-358"><a href="#cb14-358"></a><span class="in">    # Calculate padding needed</span></span>
<span id="cb14-359"><a href="#cb14-359"></a><span class="in">    pad_beg = (</span></span>
<span id="cb14-360"><a href="#cb14-360"></a><span class="in">        max(1 - start_indices[1], 0),</span></span>
<span id="cb14-361"><a href="#cb14-361"></a><span class="in">        max(1 - start_indices[2], 0),</span></span>
<span id="cb14-362"><a href="#cb14-362"></a><span class="in">        max(1 - start_indices[3], 0)</span></span>
<span id="cb14-363"><a href="#cb14-363"></a><span class="in">    )</span></span>
<span id="cb14-364"><a href="#cb14-364"></a><span class="in">    pad_end = (</span></span>
<span id="cb14-365"><a href="#cb14-365"></a><span class="in">        max(end_indices[1] - size(image, 1), 0),</span></span>
<span id="cb14-366"><a href="#cb14-366"></a><span class="in">        max(end_indices[2] - size(image, 2), 0),</span></span>
<span id="cb14-367"><a href="#cb14-367"></a><span class="in">        max(end_indices[3] - size(image, 3), 0)</span></span>
<span id="cb14-368"><a href="#cb14-368"></a><span class="in">    )</span></span>
<span id="cb14-369"><a href="#cb14-369"></a></span>
<span id="cb14-370"><a href="#cb14-370"></a><span class="in">    # Adjust start_indices and end_indices after padding</span></span>
<span id="cb14-371"><a href="#cb14-371"></a><span class="in">    start_indices_adj = start_indices .+ pad_beg</span></span>
<span id="cb14-372"><a href="#cb14-372"></a><span class="in">    end_indices_adj = end_indices .+ pad_beg</span></span>
<span id="cb14-373"><a href="#cb14-373"></a></span>
<span id="cb14-374"><a href="#cb14-374"></a><span class="in">    # Convert padding values to integers</span></span>
<span id="cb14-375"><a href="#cb14-375"></a><span class="in">    pad_beg = Tuple(round.(Int, pad_beg))</span></span>
<span id="cb14-376"><a href="#cb14-376"></a><span class="in">    pad_end = Tuple(round.(Int, pad_end))</span></span>
<span id="cb14-377"><a href="#cb14-377"></a></span>
<span id="cb14-378"><a href="#cb14-378"></a><span class="in">    # Pad the image and label using pad_mi</span></span>
<span id="cb14-379"><a href="#cb14-379"></a><span class="in">    image_padded = pad_mi(image, pad_beg, pad_end, 0)</span></span>
<span id="cb14-380"><a href="#cb14-380"></a><span class="in">    label_padded = pad_mi(label, pad_beg, pad_end, 0)</span></span>
<span id="cb14-381"><a href="#cb14-381"></a></span>
<span id="cb14-382"><a href="#cb14-382"></a><span class="in">    # Extract the patch</span></span>
<span id="cb14-383"><a href="#cb14-383"></a><span class="in">    image_patch = image_padded[</span></span>
<span id="cb14-384"><a href="#cb14-384"></a><span class="in">        start_indices_adj[1]:end_indices_adj[1],</span></span>
<span id="cb14-385"><a href="#cb14-385"></a><span class="in">        start_indices_adj[2]:end_indices_adj[2],</span></span>
<span id="cb14-386"><a href="#cb14-386"></a><span class="in">        start_indices_adj[3]:end_indices_adj[3]</span></span>
<span id="cb14-387"><a href="#cb14-387"></a><span class="in">    ]</span></span>
<span id="cb14-388"><a href="#cb14-388"></a><span class="in">    label_patch = label_padded[</span></span>
<span id="cb14-389"><a href="#cb14-389"></a><span class="in">        start_indices_adj[1]:end_indices_adj[1],</span></span>
<span id="cb14-390"><a href="#cb14-390"></a><span class="in">        start_indices_adj[2]:end_indices_adj[2],</span></span>
<span id="cb14-391"><a href="#cb14-391"></a><span class="in">        start_indices_adj[3]:end_indices_adj[3]</span></span>
<span id="cb14-392"><a href="#cb14-392"></a><span class="in">    ]</span></span>
<span id="cb14-393"><a href="#cb14-393"></a></span>
<span id="cb14-394"><a href="#cb14-394"></a><span class="in">    return image_patch, label_patch</span></span>
<span id="cb14-395"><a href="#cb14-395"></a><span class="in">end</span></span>
<span id="cb14-396"><a href="#cb14-396"></a></span>
<span id="cb14-397"><a href="#cb14-397"></a><span class="in">function get_random_patch(image, label, patch_size)</span></span>
<span id="cb14-398"><a href="#cb14-398"></a><span class="in">    println("Extracting a random patch.")</span></span>
<span id="cb14-399"><a href="#cb14-399"></a><span class="in">    # Check if the patch size is greater than the image dimensions</span></span>
<span id="cb14-400"><a href="#cb14-400"></a><span class="in">    if any(patch_size .&gt; size(image))</span></span>
<span id="cb14-401"><a href="#cb14-401"></a><span class="in">        # Calculate the needed size to fit the patch</span></span>
<span id="cb14-402"><a href="#cb14-402"></a><span class="in">        needed_size = map(max, size(image), patch_size)</span></span>
<span id="cb14-403"><a href="#cb14-403"></a><span class="in">        # Use crop_or_pad to ensure the image and label are at least as large as needed_size</span></span>
<span id="cb14-404"><a href="#cb14-404"></a><span class="in">        image = crop_or_pad(image, needed_size)</span></span>
<span id="cb14-405"><a href="#cb14-405"></a><span class="in">        label = crop_or_pad(label, needed_size)</span></span>
<span id="cb14-406"><a href="#cb14-406"></a><span class="in">    end</span></span>
<span id="cb14-407"><a href="#cb14-407"></a></span>
<span id="cb14-408"><a href="#cb14-408"></a><span class="in">    # Calculate random start indices within the new allowable range</span></span>
<span id="cb14-409"><a href="#cb14-409"></a><span class="in">    start_x = rand(1:size(image, 1) - patch_size[1] + 1)</span></span>
<span id="cb14-410"><a href="#cb14-410"></a><span class="in">    start_y = rand(1:size(image, 2) - patch_size[2] + 1)</span></span>
<span id="cb14-411"><a href="#cb14-411"></a><span class="in">    start_z = rand(1:size(image, 3) - patch_size[3] + 1)</span></span>
<span id="cb14-412"><a href="#cb14-412"></a><span class="in">    start_indices = [start_x, start_y, start_z]</span></span>
<span id="cb14-413"><a href="#cb14-413"></a><span class="in">    end_indices = start_indices .+ patch_size .- 1</span></span>
<span id="cb14-414"><a href="#cb14-414"></a></span>
<span id="cb14-415"><a href="#cb14-415"></a><span class="in">    # Extract the patch directly when within bounds</span></span>
<span id="cb14-416"><a href="#cb14-416"></a><span class="in">    image_patch = image[start_indices[1]:end_indices[1], start_indices[2]:end_indices[2], start_indices[3]:end_indices[3]]</span></span>
<span id="cb14-417"><a href="#cb14-417"></a><span class="in">    label_patch = label[start_indices[1]:end_indices[1], start_indices[2]:end_indices[2], start_indices[3]:end_indices[3]]</span></span>
<span id="cb14-418"><a href="#cb14-418"></a></span>
<span id="cb14-419"><a href="#cb14-419"></a><span class="in">    return image_patch, label_patch</span></span>
<span id="cb14-420"><a href="#cb14-420"></a><span class="in">end</span></span>
<span id="cb14-421"><a href="#cb14-421"></a></span>
<span id="cb14-422"><a href="#cb14-422"></a><span class="in">```</span></span>
<span id="cb14-423"><a href="#cb14-423"></a>&lt;/details&gt;</span>
<span id="cb14-424"><a href="#cb14-424"></a></span>
<span id="cb14-425"><a href="#cb14-425"></a><span class="fu">## Calculate Median and Mean Spacing with resampling 🆙</span></span>
<span id="cb14-426"><a href="#cb14-426"></a>This part ensures that all images in the dataset have consistent real coordinates, spacing, and shape. It's a critical factor in medical imaging for accurate analysis. Calculating and applying set values, median or mean across images ensures uniformity.</span>
<span id="cb14-427"><a href="#cb14-427"></a></span>
<span id="cb14-428"><a href="#cb14-428"></a><span class="fu">#### Resample images to target image 🆙</span></span>
<span id="cb14-429"><a href="#cb14-429"></a>This step aligns each image to the reference coordinates of the main image, ensuring that all images share a common spatial alignment. The <span class="in">`resample_to_image`</span> function from MedImage.jl is used here, applying interpolation to adjust each image.</span>
<span id="cb14-430"><a href="#cb14-430"></a></span>
<span id="cb14-431"><a href="#cb14-431"></a></span>
<span id="cb14-432"><a href="#cb14-432"></a>&lt;details&gt;</span>
<span id="cb14-433"><a href="#cb14-433"></a>&lt;summary&gt;resample_images_to_target:&lt;/summary&gt;</span>
<span id="cb14-434"><a href="#cb14-434"></a></span>
<span id="cb14-435"><a href="#cb14-435"></a><span class="in">```julia</span></span>
<span id="cb14-436"><a href="#cb14-436"></a><span class="in">if resample_images_to_target &amp;&amp; !isempty(Med_images)</span></span>
<span id="cb14-437"><a href="#cb14-437"></a><span class="in">    println("Resampling $channel_type files in channel '$channel_folder' to the first $channel_type in the channel.")</span></span>
<span id="cb14-438"><a href="#cb14-438"></a><span class="in">    reference_image = Med_images[1]</span></span>
<span id="cb14-439"><a href="#cb14-439"></a><span class="in">    Med_images = [resample_to_image(reference_image, img, interpolator) for img in Med_images]</span></span>
<span id="cb14-440"><a href="#cb14-440"></a><span class="in">end</span></span>
<span id="cb14-441"><a href="#cb14-441"></a><span class="in">```</span></span>
<span id="cb14-442"><a href="#cb14-442"></a>&lt;/details&gt;</span>
<span id="cb14-443"><a href="#cb14-443"></a></span>
<span id="cb14-444"><a href="#cb14-444"></a>Comment:&lt;br&gt;</span>
<span id="cb14-445"><a href="#cb14-445"></a><span class="in">`Resample_to_image`</span> uses interpolation that is not yet GPU-accelerated in this implementation, this step slows down the data preparation phase significantly.</span>
<span id="cb14-446"><a href="#cb14-446"></a></span>
<span id="cb14-447"><a href="#cb14-447"></a><span class="fu">#### Ensure uniform spacing across the entire dataset 🆙</span></span>
<span id="cb14-448"><a href="#cb14-448"></a>This step brings all images to a consistent voxel spacing across the dataset using <span class="in">`resample_to_spacing`</span> from MedImage.jl. This uniform spacing is crucial for creating a standardized dataset where each image voxel represents the same physical volume.</span>
<span id="cb14-449"><a href="#cb14-449"></a></span>
<span id="cb14-450"><a href="#cb14-450"></a></span>
<span id="cb14-451"><a href="#cb14-451"></a>&lt;details&gt;</span>
<span id="cb14-452"><a href="#cb14-452"></a>&lt;summary&gt;esample_to_spacing:&lt;/summary&gt;</span>
<span id="cb14-453"><a href="#cb14-453"></a></span>
<span id="cb14-454"><a href="#cb14-454"></a><span class="in">```julia</span></span>
<span id="cb14-455"><a href="#cb14-455"></a><span class="in">if resample_images_spacing == "set"</span></span>
<span id="cb14-456"><a href="#cb14-456"></a><span class="in">    println("Resampling all $channel_type files to target spacing: $target_spacing")</span></span>
<span id="cb14-457"><a href="#cb14-457"></a><span class="in">    target_spacing = Tuple(Float32(s) for s in target_spacing)</span></span>
<span id="cb14-458"><a href="#cb14-458"></a><span class="in">    channels_data = [[resample_to_spacing(img, target_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-459"><a href="#cb14-459"></a><span class="in">elseif resample_images_spacing == "avg"</span></span>
<span id="cb14-460"><a href="#cb14-460"></a><span class="in">    println("Calculating average spacing across all $channel_type files and resampling.")</span></span>
<span id="cb14-461"><a href="#cb14-461"></a><span class="in">    all_spacings = [img.spacing for channel in channels_data for img in channel]</span></span>
<span id="cb14-462"><a href="#cb14-462"></a><span class="in">    avg_spacing = Tuple(Float32(mean(s)) for s in zip(all_spacings...))</span></span>
<span id="cb14-463"><a href="#cb14-463"></a><span class="in">    println("Average spacing calculated: $avg_spacing")</span></span>
<span id="cb14-464"><a href="#cb14-464"></a><span class="in">    channels_data = [[resample_to_spacing(img, avg_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-465"><a href="#cb14-465"></a><span class="in">elseif resample_images_spacing == "median"</span></span>
<span id="cb14-466"><a href="#cb14-466"></a><span class="in">    println("Calculating median spacing across all $channel_type files and resampling.")</span></span>
<span id="cb14-467"><a href="#cb14-467"></a><span class="in">    all_spacings = [img.spacing for channel in channels_data for img in channel]</span></span>
<span id="cb14-468"><a href="#cb14-468"></a><span class="in">    median_spacing = Tuple(Float32(median(s)) for s in all_spacings)</span></span>
<span id="cb14-469"><a href="#cb14-469"></a><span class="in">    println("Median spacing calculated: $median_spacing")</span></span>
<span id="cb14-470"><a href="#cb14-470"></a><span class="in">    channels_data = [[resample_to_spacing(img, median_spacing, interpolator) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-471"><a href="#cb14-471"></a><span class="in">elseif resample_images_spacing == false</span></span>
<span id="cb14-472"><a href="#cb14-472"></a><span class="in">    println("Skipping resampling of $channel_type files.")</span></span>
<span id="cb14-473"><a href="#cb14-473"></a><span class="in">    # No resampling will be applied, channels_data remains unchanged.</span></span>
<span id="cb14-474"><a href="#cb14-474"></a><span class="in">end</span></span>
<span id="cb14-475"><a href="#cb14-475"></a><span class="in">```</span></span>
<span id="cb14-476"><a href="#cb14-476"></a>&lt;/details&gt;</span>
<span id="cb14-477"><a href="#cb14-477"></a></span>
<span id="cb14-478"><a href="#cb14-478"></a>Comment:&lt;br&gt;</span>
<span id="cb14-479"><a href="#cb14-479"></a><span class="in">`Resample_to_spacing`</span> uses interpolation that is not yet GPU-accelerated in this implementation, this step slows down the data preparation phase significantly.</span>
<span id="cb14-480"><a href="#cb14-480"></a></span>
<span id="cb14-481"><a href="#cb14-481"></a><span class="fu">#### Resizing all channel files to average or target size ✅</span></span>
<span id="cb14-482"><a href="#cb14-482"></a>To create a cohesive 5D tensor, all images in each channel are resized to a uniform shape, either the average size of all images or a specific target size. This resizing process uses <span class="in">`crop_or_pad`</span>, ensuring that all images match the specified dimensions, making them suitable for model input.</span>
<span id="cb14-483"><a href="#cb14-483"></a></span>
<span id="cb14-484"><a href="#cb14-484"></a>&lt;details&gt;</span>
<span id="cb14-485"><a href="#cb14-485"></a>&lt;summary&gt;crop_or_pad:&lt;/summary&gt;</span>
<span id="cb14-486"><a href="#cb14-486"></a></span>
<span id="cb14-487"><a href="#cb14-487"></a><span class="in">```julia</span></span>
<span id="cb14-488"><a href="#cb14-488"></a><span class="in">if resample_size == "avg"</span></span>
<span id="cb14-489"><a href="#cb14-489"></a><span class="in">    sizes = [size(img.voxel_data) for img in channels_data for img in img]  # Get sizes from all images</span></span>
<span id="cb14-490"><a href="#cb14-490"></a><span class="in">    avg_dim = map(mean, zip(sizes...))</span></span>
<span id="cb14-491"><a href="#cb14-491"></a><span class="in">    avg_dim = Tuple(Int(round(d)) for d in avg_dim)</span></span>
<span id="cb14-492"><a href="#cb14-492"></a><span class="in">    println("Resizing all $channel_type files to average dimension: $avg_dim")</span></span>
<span id="cb14-493"><a href="#cb14-493"></a><span class="in">    channels_data = [[crop_or_pad(img, avg_dim) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-494"><a href="#cb14-494"></a><span class="in">elseif resample_size != "avg"</span></span>
<span id="cb14-495"><a href="#cb14-495"></a><span class="in">    target_dim = Tuple(resample_size)</span></span>
<span id="cb14-496"><a href="#cb14-496"></a><span class="in">    println("Resizing all $channel_type files to target dimension: $target_dim")</span></span>
<span id="cb14-497"><a href="#cb14-497"></a><span class="in">    channels_data = [[crop_or_pad(img, target_dim) for img in channel] for channel in channels_data]</span></span>
<span id="cb14-498"><a href="#cb14-498"></a><span class="in">end</span></span>
<span id="cb14-499"><a href="#cb14-499"></a><span class="in">```</span></span>
<span id="cb14-500"><a href="#cb14-500"></a>&lt;/details&gt;</span>
<span id="cb14-501"><a href="#cb14-501"></a></span>
<span id="cb14-502"><a href="#cb14-502"></a><span class="fu">## Basic Post-processing operations</span></span>
<span id="cb14-503"><a href="#cb14-503"></a>Post-processing operations involve the algorithm <span class="in">`largest_connected_components`</span>. It is achieved by label initialization and propagation in the segmented mask.</span>
<span id="cb14-504"><a href="#cb14-504"></a>The <span class="in">`initialize_labels_kernel`</span> function assigns unique labels to different regions.</span>
<span id="cb14-505"><a href="#cb14-505"></a></span>
<span id="cb14-506"><a href="#cb14-506"></a>&lt;details&gt;</span>
<span id="cb14-507"><a href="#cb14-507"></a>&lt;summary&gt;initialize_labels_kernel:&lt;/summary&gt;</span>
<span id="cb14-508"><a href="#cb14-508"></a></span>
<span id="cb14-509"><a href="#cb14-509"></a><span class="in">```julia</span></span>
<span id="cb14-510"><a href="#cb14-510"></a><span class="in">@kernel function initialize_labels_kernel(mask, labels, width, height, depth)</span></span>
<span id="cb14-511"><a href="#cb14-511"></a><span class="in">    idx = @index(Global, Cartesian)</span></span>
<span id="cb14-512"><a href="#cb14-512"></a><span class="in">    i = idx[1]</span></span>
<span id="cb14-513"><a href="#cb14-513"></a><span class="in">    j = idx[2]</span></span>
<span id="cb14-514"><a href="#cb14-514"></a><span class="in">    k = idx[3]</span></span>
<span id="cb14-515"><a href="#cb14-515"></a><span class="in">    </span></span>
<span id="cb14-516"><a href="#cb14-516"></a><span class="in">    if i &gt;= 1 &amp;&amp; i &lt;= width &amp;&amp; j &gt;= 1 &amp;&amp; j &lt;= height &amp;&amp; k &gt;= 1 &amp;&amp; k &lt;= depth</span></span>
<span id="cb14-517"><a href="#cb14-517"></a><span class="in">        if mask[i, j, k] == 1</span></span>
<span id="cb14-518"><a href="#cb14-518"></a><span class="in">            labels[i, j, k] = i + (j - 1) * width + (k - 1) * width * height</span></span>
<span id="cb14-519"><a href="#cb14-519"></a><span class="in">        else</span></span>
<span id="cb14-520"><a href="#cb14-520"></a><span class="in">            labels[i, j, k] = 0</span></span>
<span id="cb14-521"><a href="#cb14-521"></a><span class="in">        end</span></span>
<span id="cb14-522"><a href="#cb14-522"></a><span class="in">    end</span></span>
<span id="cb14-523"><a href="#cb14-523"></a><span class="in">end</span></span>
<span id="cb14-524"><a href="#cb14-524"></a><span class="in">```</span></span>
<span id="cb14-525"><a href="#cb14-525"></a>&lt;/details&gt;</span>
<span id="cb14-526"><a href="#cb14-526"></a>Propagate_labels_kernel iteratively updates the labels to maintain connected regions.</span>
<span id="cb14-527"><a href="#cb14-527"></a>propagate_labels_kernel:</span>
<span id="cb14-528"><a href="#cb14-528"></a>&lt;details&gt;</span>
<span id="cb14-529"><a href="#cb14-529"></a></span>
<span id="cb14-530"><a href="#cb14-530"></a><span class="in">```julia</span></span>
<span id="cb14-531"><a href="#cb14-531"></a><span class="in">@kernel function propagate_labels_kernel(mask, labels, width, height, depth)</span></span>
<span id="cb14-532"><a href="#cb14-532"></a><span class="in">    idx= @index(Global, Cartesian)</span></span>
<span id="cb14-533"><a href="#cb14-533"></a><span class="in">    i = idx[1]</span></span>
<span id="cb14-534"><a href="#cb14-534"></a><span class="in">    j = idx[2]</span></span>
<span id="cb14-535"><a href="#cb14-535"></a><span class="in">    k = idx[3]</span></span>
<span id="cb14-536"><a href="#cb14-536"></a></span>
<span id="cb14-537"><a href="#cb14-537"></a><span class="in">    if i &gt;= 1 &amp;&amp; i &lt;= width &amp;&amp; j &gt;= 1 &amp;&amp; j &lt;= height &amp;&amp; k &gt;= 1 &amp;&amp; k &lt;= depth</span></span>
<span id="cb14-538"><a href="#cb14-538"></a><span class="in">        if mask[i, j, k] == 1</span></span>
<span id="cb14-539"><a href="#cb14-539"></a><span class="in">            current_label = labels[i, j, k]</span></span>
<span id="cb14-540"><a href="#cb14-540"></a><span class="in">            for di in -1:1</span></span>
<span id="cb14-541"><a href="#cb14-541"></a><span class="in">                for dj in -1:1</span></span>
<span id="cb14-542"><a href="#cb14-542"></a><span class="in">                    for dk in -1:1</span></span>
<span id="cb14-543"><a href="#cb14-543"></a><span class="in">                        if di == 0 &amp;&amp; dj == 0 &amp;&amp; dk == 0</span></span>
<span id="cb14-544"><a href="#cb14-544"></a><span class="in">                            continue</span></span>
<span id="cb14-545"><a href="#cb14-545"></a><span class="in">                        end</span></span>
<span id="cb14-546"><a href="#cb14-546"></a><span class="in">                        ni = i + di</span></span>
<span id="cb14-547"><a href="#cb14-547"></a><span class="in">                        nj = j + dj</span></span>
<span id="cb14-548"><a href="#cb14-548"></a><span class="in">                        nk = k + dk</span></span>
<span id="cb14-549"><a href="#cb14-549"></a><span class="in">                        if ni &gt;= 1 &amp;&amp; ni &lt;= width &amp;&amp; nj &gt;= 1 &amp;&amp; nj &lt;= height &amp;&amp; nk &gt;= 1 &amp;&amp; nk &lt;= depth</span></span>
<span id="cb14-550"><a href="#cb14-550"></a><span class="in">                            if mask[ni, nj, nk] == 1 &amp;&amp; labels[ni, nj, nk] &lt; current_label</span></span>
<span id="cb14-551"><a href="#cb14-551"></a><span class="in">                                labels[i, j, k] = labels[ni, nj, nk]</span></span>
<span id="cb14-552"><a href="#cb14-552"></a><span class="in">                            end</span></span>
<span id="cb14-553"><a href="#cb14-553"></a><span class="in">                        end</span></span>
<span id="cb14-554"><a href="#cb14-554"></a><span class="in">                    end</span></span>
<span id="cb14-555"><a href="#cb14-555"></a><span class="in">                end</span></span>
<span id="cb14-556"><a href="#cb14-556"></a><span class="in">            end</span></span>
<span id="cb14-557"><a href="#cb14-557"></a><span class="in">        end</span></span>
<span id="cb14-558"><a href="#cb14-558"></a><span class="in">    end</span></span>
<span id="cb14-559"><a href="#cb14-559"></a><span class="in">end</span></span>
<span id="cb14-560"><a href="#cb14-560"></a><span class="in">```</span></span>
<span id="cb14-561"><a href="#cb14-561"></a>&lt;/details&gt;</span>
<span id="cb14-562"><a href="#cb14-562"></a>This process facilitates the identification of the largest connected components in 3D space, helping to isolate relevant medical structures, such as tumors, in the segmented mask. Allowing determining how many such areas are to be returned.</span>
<span id="cb14-563"><a href="#cb14-563"></a></span>
<span id="cb14-564"><a href="#cb14-564"></a>&lt;details&gt;</span>
<span id="cb14-565"><a href="#cb14-565"></a>&lt;summary&gt;largest_connected_components:&lt;/summary&gt;</span>
<span id="cb14-566"><a href="#cb14-566"></a></span>
<span id="cb14-567"><a href="#cb14-567"></a><span class="in">```julia</span></span>
<span id="cb14-568"><a href="#cb14-568"></a><span class="in">function largest_connected_components(mask::Array{Int32, 3}, n_lcc::Int)</span></span>
<span id="cb14-569"><a href="#cb14-569"></a><span class="in">    width, height, depth = size(mask)</span></span>
<span id="cb14-570"><a href="#cb14-570"></a><span class="in">    mask_gpu = CuArray(mask)</span></span>
<span id="cb14-571"><a href="#cb14-571"></a><span class="in">    labels_gpu = CUDA.fill(0, size(mask))</span></span>
<span id="cb14-572"><a href="#cb14-572"></a><span class="in">    dev = get_backend(labels_gpu)</span></span>
<span id="cb14-573"><a href="#cb14-573"></a><span class="in">    ndrange = (width, height, depth)</span></span>
<span id="cb14-574"><a href="#cb14-574"></a><span class="in">    workgroupsize = (3, 3, 3)</span></span>
<span id="cb14-575"><a href="#cb14-575"></a></span>
<span id="cb14-576"><a href="#cb14-576"></a><span class="in">    # Initialize labels</span></span>
<span id="cb14-577"><a href="#cb14-577"></a><span class="in">    initialize_labels_kernel(dev)(mask_gpu, labels_gpu, width, height, depth, ndrange = ndrange)</span></span>
<span id="cb14-578"><a href="#cb14-578"></a><span class="in">    CUDA.synchronize()</span></span>
<span id="cb14-579"><a href="#cb14-579"></a></span>
<span id="cb14-580"><a href="#cb14-580"></a><span class="in">    # Propagate labels iteratively</span></span>
<span id="cb14-581"><a href="#cb14-581"></a><span class="in">    for _ in 1:10 </span></span>
<span id="cb14-582"><a href="#cb14-582"></a><span class="in">        propagate_labels_kernel(dev, workgroupsize)(mask_gpu, labels_gpu, width, height, depth, ndrange = ndrange)</span></span>
<span id="cb14-583"><a href="#cb14-583"></a><span class="in">        CUDA.synchronize()</span></span>
<span id="cb14-584"><a href="#cb14-584"></a><span class="in">    end</span></span>
<span id="cb14-585"><a href="#cb14-585"></a></span>
<span id="cb14-586"><a href="#cb14-586"></a><span class="in">    # Download labels back to CPU</span></span>
<span id="cb14-587"><a href="#cb14-587"></a><span class="in">    labels_cpu = Array(labels_gpu)</span></span>
<span id="cb14-588"><a href="#cb14-588"></a><span class="in">    </span></span>
<span id="cb14-589"><a href="#cb14-589"></a><span class="in">    # Find all unique labels and their sizes</span></span>
<span id="cb14-590"><a href="#cb14-590"></a><span class="in">    unique_labels = unique(labels_cpu)</span></span>
<span id="cb14-591"><a href="#cb14-591"></a><span class="in">    label_sizes = [(label, count(labels_cpu .== label)) for label in unique_labels if label != 0]</span></span>
<span id="cb14-592"><a href="#cb14-592"></a></span>
<span id="cb14-593"><a href="#cb14-593"></a><span class="in">    # Sort labels by size and get the top n_lcc</span></span>
<span id="cb14-594"><a href="#cb14-594"></a><span class="in">    sort!(label_sizes, by = x -&gt; x[2], rev = true)</span></span>
<span id="cb14-595"><a href="#cb14-595"></a><span class="in">    top_labels = label_sizes[1:min(n_lcc, length(label_sizes))]</span></span>
<span id="cb14-596"><a href="#cb14-596"></a></span>
<span id="cb14-597"><a href="#cb14-597"></a><span class="in">    # Create a mask for each of the top n_lcc components</span></span>
<span id="cb14-598"><a href="#cb14-598"></a><span class="in">    components = [labels_cpu .== label[1] for label in top_labels]</span></span>
<span id="cb14-599"><a href="#cb14-599"></a><span class="in">    return components</span></span>
<span id="cb14-600"><a href="#cb14-600"></a><span class="in">end</span></span>
<span id="cb14-601"><a href="#cb14-601"></a><span class="in">```</span></span>
<span id="cb14-602"><a href="#cb14-602"></a>&lt;/details&gt;</span>
<span id="cb14-603"><a href="#cb14-603"></a></span>
<span id="cb14-604"><a href="#cb14-604"></a><span class="fu">## Structured configuration of all hyperparameters 🆙</span></span>
<span id="cb14-605"><a href="#cb14-605"></a></span>
<span id="cb14-606"><a href="#cb14-606"></a>Hyperparameters for the entire pipeline are stored in a JSON configuration file, enabling straightforward adjustments for experimentation (just swap values, save and resume the study). This structured setup allows easy modification of key parameters, such as data set preparation, training settings, data augmentation, and resampling options.</span>
<span id="cb14-607"><a href="#cb14-607"></a></span>
<span id="cb14-608"><a href="#cb14-608"></a></span>
<span id="cb14-609"><a href="#cb14-609"></a>&lt;details&gt;</span>
<span id="cb14-610"><a href="#cb14-610"></a>&lt;summary&gt;Example configuration:&lt;/summary&gt;</span>
<span id="cb14-611"><a href="#cb14-611"></a></span>
<span id="cb14-612"><a href="#cb14-612"></a><span class="in">```JSON</span></span>
<span id="cb14-613"><a href="#cb14-613"></a><span class="fu">{</span></span>
<span id="cb14-614"><a href="#cb14-614"></a>    <span class="dt">"model"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-615"><a href="#cb14-615"></a>        <span class="dt">"patience"</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span></span>
<span id="cb14-616"><a href="#cb14-616"></a>        <span class="dt">"early_stopping_metric"</span><span class="fu">:</span> <span class="st">"val_loss"</span><span class="fu">,</span></span>
<span id="cb14-617"><a href="#cb14-617"></a>        <span class="dt">"optimizer_name"</span><span class="fu">:</span> <span class="st">"Adam"</span><span class="fu">,</span></span>
<span id="cb14-618"><a href="#cb14-618"></a>        <span class="dt">"loss_function_name"</span><span class="fu">:</span> <span class="st">"l1"</span><span class="fu">,</span></span>
<span id="cb14-619"><a href="#cb14-619"></a>        <span class="dt">"early_stopping"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb14-620"><a href="#cb14-620"></a>        <span class="dt">"early_stopping_min_delta"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.01</span><span class="fu">,</span></span>
<span id="cb14-621"><a href="#cb14-621"></a>        <span class="dt">"optimizer_args"</span><span class="fu">:</span> <span class="st">"lr=0.001"</span><span class="fu">,</span></span>
<span id="cb14-622"><a href="#cb14-622"></a>        <span class="dt">"num_epochs"</span><span class="fu">:</span> <span class="dv">10</span></span>
<span id="cb14-623"><a href="#cb14-623"></a>    <span class="fu">},</span></span>
<span id="cb14-624"><a href="#cb14-624"></a>    <span class="dt">"data"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-625"><a href="#cb14-625"></a>        <span class="dt">"batch_complete"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-626"><a href="#cb14-626"></a>        <span class="dt">"resample_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">200</span><span class="ot">,</span><span class="dv">101</span><span class="ot">,</span><span class="dv">49</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-627"><a href="#cb14-627"></a>        <span class="dt">"resample_to_target"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-628"><a href="#cb14-628"></a>        <span class="dt">"resample_to_spacing"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-629"><a href="#cb14-629"></a>        <span class="dt">"batch_size"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb14-630"><a href="#cb14-630"></a>        <span class="dt">"standardization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-631"><a href="#cb14-631"></a>        <span class="dt">"target_spacing"</span><span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span></span>
<span id="cb14-632"><a href="#cb14-632"></a>        <span class="dt">"channel_size"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb14-633"><a href="#cb14-633"></a>        <span class="dt">"normalization"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-634"><a href="#cb14-634"></a>        <span class="dt">"has_mask"</span><span class="fu">:</span> <span class="kw">true</span></span>
<span id="cb14-635"><a href="#cb14-635"></a>    <span class="fu">},</span></span>
<span id="cb14-636"><a href="#cb14-636"></a>    <span class="dt">"augmentation"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-637"><a href="#cb14-637"></a>        <span class="dt">"augmentations"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-638"><a href="#cb14-638"></a>            <span class="dt">"Brightness transform"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-639"><a href="#cb14-639"></a>                <span class="dt">"mode"</span><span class="fu">:</span> <span class="st">"additive"</span><span class="fu">,</span></span>
<span id="cb14-640"><a href="#cb14-640"></a>                <span class="dt">"value"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb14-641"><a href="#cb14-641"></a>            <span class="fu">}</span></span>
<span id="cb14-642"><a href="#cb14-642"></a>        <span class="fu">},</span></span>
<span id="cb14-643"><a href="#cb14-643"></a>        <span class="dt">"p_rand"</span><span class="fu">:</span> <span class="dv">0</span><span class="er">.</span><span class="dv">5</span><span class="fu">,</span></span>
<span id="cb14-644"><a href="#cb14-644"></a>        <span class="dt">"processing_unit"</span><span class="fu">:</span> <span class="st">"GPU"</span><span class="fu">,</span></span>
<span id="cb14-645"><a href="#cb14-645"></a>        <span class="dt">"order"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb14-646"><a href="#cb14-646"></a>            <span class="st">"Brightness transform"</span></span>
<span id="cb14-647"><a href="#cb14-647"></a>        <span class="ot">]</span></span>
<span id="cb14-648"><a href="#cb14-648"></a>    <span class="fu">},</span></span>
<span id="cb14-649"><a href="#cb14-649"></a>    <span class="dt">"learning"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb14-650"><a href="#cb14-650"></a>        <span class="dt">"Train_Val_Test_JSON"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-651"><a href="#cb14-651"></a>        <span class="dt">"largest_connected_component"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-652"><a href="#cb14-652"></a>        <span class="dt">"n_lcc"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb14-653"><a href="#cb14-653"></a>        <span class="dt">"n_folds"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb14-654"><a href="#cb14-654"></a>        <span class="dt">"invertible_augmentations"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-655"><a href="#cb14-655"></a>        <span class="dt">"n_invertible"</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></span>
<span id="cb14-656"><a href="#cb14-656"></a>        </span>
<span id="cb14-657"><a href="#cb14-657"></a>        <span class="dt">"class_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-658"><a href="#cb14-658"></a>        <span class="dt">"additional_JSON_path"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-659"><a href="#cb14-659"></a>        <span class="dt">"patch_size"</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">,</span><span class="dv">50</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-660"><a href="#cb14-660"></a>        <span class="dt">"metric"</span><span class="fu">:</span> <span class="st">"dice"</span><span class="fu">,</span></span>
<span id="cb14-661"><a href="#cb14-661"></a>        <span class="dt">"n_cross_val"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-662"><a href="#cb14-662"></a>        <span class="dt">"patch_probabilistic_oversampling"</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb14-663"><a href="#cb14-663"></a>        <span class="dt">"oversampling_probability"</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span></span>
<span id="cb14-664"><a href="#cb14-664"></a>        <span class="dt">"test_train_validation"</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb14-665"><a href="#cb14-665"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">6</span><span class="ot">,</span></span>
<span id="cb14-666"><a href="#cb14-666"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span><span class="ot">,</span></span>
<span id="cb14-667"><a href="#cb14-667"></a>            <span class="dv">0</span><span class="er">.</span><span class="dv">2</span></span>
<span id="cb14-668"><a href="#cb14-668"></a>        <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb14-669"><a href="#cb14-669"></a>        <span class="dt">"shuffle"</span><span class="fu">:</span> <span class="kw">false</span></span>
<span id="cb14-670"><a href="#cb14-670"></a>    <span class="fu">}</span></span>
<span id="cb14-671"><a href="#cb14-671"></a><span class="fu">}</span></span>
<span id="cb14-672"><a href="#cb14-672"></a></span>
<span id="cb14-673"><a href="#cb14-673"></a><span class="in">```</span></span>
<span id="cb14-674"><a href="#cb14-674"></a>&lt;/details&gt;</span>
<span id="cb14-675"><a href="#cb14-675"></a></span>
<span id="cb14-676"><a href="#cb14-676"></a>Comments:&lt;br&gt;</span>
<span id="cb14-677"><a href="#cb14-677"></a>The current configuration is loaded as a dictionary, which simplifies access and modification. This setup presents a strong foundation for integrating automated search algorithms for hyperparameter tuning, enabling more efficient model optimization.&lt;br&gt;</span>
<span id="cb14-678"><a href="#cb14-678"></a>The configuration structure could be reorganized and re-named to improve readability, making it easier for users to locate and adjust specific parameters.</span>
<span id="cb14-679"><a href="#cb14-679"></a></span>
<span id="cb14-680"><a href="#cb14-680"></a><span class="fu">## Visualization of algorithm outputs ⚠️</span></span>
<span id="cb14-681"><a href="#cb14-681"></a>This module provides basic visualization functionality by saving output masks and images first to MedImage format and then to Nifti format. The <span class="in">`create_nii_from_medimage`</span> function from MedImage.jl generates Nifti files, which can be loaded into MedEye3D for 3D visualization.</span>
<span id="cb14-682"><a href="#cb14-682"></a></span>
<span id="cb14-683"><a href="#cb14-683"></a>Comments:&lt;br&gt;</span>
<span id="cb14-684"><a href="#cb14-684"></a>Integrating this visualization module more fully with the pipeline could eliminate unnecessary steps. By automatically loading output masks and images as raw data into MedEye3D for 3D visualization and supporting a more efficient end-to-end workflow. </span>
<span id="cb14-685"><a href="#cb14-685"></a></span>
<span id="cb14-686"><a href="#cb14-686"></a><span class="fu">## K-fold cross-validation functionality ✅</span></span>
<span id="cb14-687"><a href="#cb14-687"></a>K-fold cross-validation is implemented to evaluate model performance more robustly. The data is split into multiple folds, with each fold serving as a validation set once, while the others form the training set. This functionality provides a better assessment of model performance across different subsets of the data.</span>
<span id="cb14-688"><a href="#cb14-688"></a></span>
<span id="cb14-689"><a href="#cb14-689"></a>&lt;details&gt;</span>
<span id="cb14-690"><a href="#cb14-690"></a>&lt;summary&gt;K-fold cross-validation functionality:&lt;/summary&gt;</span>
<span id="cb14-691"><a href="#cb14-691"></a></span>
<span id="cb14-692"><a href="#cb14-692"></a><span class="in">```julia</span></span>
<span id="cb14-693"><a href="#cb14-693"></a><span class="in">...</span></span>
<span id="cb14-694"><a href="#cb14-694"></a><span class="in">  tstate = initialize_train_state(rng, model, optimizer)</span></span>
<span id="cb14-695"><a href="#cb14-695"></a><span class="in">  if config["learning"]["n_cross_val"]</span></span>
<span id="cb14-696"><a href="#cb14-696"></a><span class="in">      n_folds = config["learning"]["n_folds"]</span></span>
<span id="cb14-697"><a href="#cb14-697"></a><span class="in">      all_tstate = []</span></span>
<span id="cb14-698"><a href="#cb14-698"></a><span class="in">      combined_indices = [indices_dict["train"]; indices_dict["validation"]]</span></span>
<span id="cb14-699"><a href="#cb14-699"></a><span class="in">      shuffled_indices = shuffle(rng, combined_indices)</span></span>
<span id="cb14-700"><a href="#cb14-700"></a><span class="in">      for fold in 1:n_folds</span></span>
<span id="cb14-701"><a href="#cb14-701"></a><span class="in">          println("Starting fold $fold/$n_folds")</span></span>
<span id="cb14-702"><a href="#cb14-702"></a><span class="in">          train_groups, validation_groups = k_fold_split(combined_indices, n_folds, fold, rng)</span></span>
<span id="cb14-703"><a href="#cb14-703"></a><span class="in">          </span></span>
<span id="cb14-704"><a href="#cb14-704"></a><span class="in">          tstate = initialize_train_state(rng, model, optimizer)</span></span>
<span id="cb14-705"><a href="#cb14-705"></a><span class="in">          final_tstate = epoch_loop(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span></span>
<span id="cb14-706"><a href="#cb14-706"></a><span class="in">          </span></span>
<span id="cb14-707"><a href="#cb14-707"></a><span class="in">          push!(all_tstate, final_tstate)</span></span>
<span id="cb14-708"><a href="#cb14-708"></a><span class="in">      end</span></span>
<span id="cb14-709"><a href="#cb14-709"></a><span class="in">  else</span></span>
<span id="cb14-710"><a href="#cb14-710"></a><span class="in">      final_tstate = epoch_loop(num_epochs, train_groups, validation_groups, h5, model, tstate, config, loss_function, num_classes)</span></span>
<span id="cb14-711"><a href="#cb14-711"></a><span class="in">  end</span></span>
<span id="cb14-712"><a href="#cb14-712"></a><span class="in">  return final_tstate</span></span>
<span id="cb14-713"><a href="#cb14-713"></a><span class="in">...  </span></span>
<span id="cb14-714"><a href="#cb14-714"></a><span class="in">```</span></span>
<span id="cb14-715"><a href="#cb14-715"></a>&lt;/details&gt;</span>
<span id="cb14-716"><a href="#cb14-716"></a></span>
<span id="cb14-717"><a href="#cb14-717"></a>The <span class="in">`k_fold_split`</span> function organizes the indices for each fold, ensuring comprehensive coverage of the dataset during training.</span>
<span id="cb14-718"><a href="#cb14-718"></a></span>
<span id="cb14-719"><a href="#cb14-719"></a>&lt;details&gt;</span>
<span id="cb14-720"><a href="#cb14-720"></a>&lt;summary&gt;k_fold_split&lt;/summary&gt;</span>
<span id="cb14-721"><a href="#cb14-721"></a></span>
<span id="cb14-722"><a href="#cb14-722"></a><span class="in">```julia</span></span>
<span id="cb14-723"><a href="#cb14-723"></a><span class="in">function k_fold_split(data, n_folds, current_fold)</span></span>
<span id="cb14-724"><a href="#cb14-724"></a><span class="in">    fold_size = length(data) ÷ n_folds</span></span>
<span id="cb14-725"><a href="#cb14-725"></a><span class="in">    validation_start = (current_fold - 1) * fold_size + 1</span></span>
<span id="cb14-726"><a href="#cb14-726"></a><span class="in">    validation_end = validation_start + fold_size - 1</span></span>
<span id="cb14-727"><a href="#cb14-727"></a><span class="in">    validation_indices = data[validation_start:validation_end]</span></span>
<span id="cb14-728"><a href="#cb14-728"></a><span class="in">    train_indices = [data[1:validation_start-1]; data[validation_end+1:end]]</span></span>
<span id="cb14-729"><a href="#cb14-729"></a><span class="in">    return train_indices, validation_indices</span></span>
<span id="cb14-730"><a href="#cb14-730"></a><span class="in">end</span></span>
<span id="cb14-731"><a href="#cb14-731"></a><span class="in">```</span></span>
<span id="cb14-732"><a href="#cb14-732"></a>&lt;/details&gt;</span>
<span id="cb14-733"><a href="#cb14-733"></a></span>
<span id="cb14-734"><a href="#cb14-734"></a><span class="fu"># Conclusions and Future Development</span></span>
<span id="cb14-735"><a href="#cb14-735"></a>I have successfully established a foundation for a medical imaging pipeline, addressing significant challenges in data handling, model training, and augmentation integration. The integration of dataset-wide functions has significantly enhanced the reproducibility and handling of batched data with GPU support enabling scalability of experiments, making it easier for researchers and practitioners to produce better results.</span>
<span id="cb14-736"><a href="#cb14-736"></a></span>
<span id="cb14-737"><a href="#cb14-737"></a><span class="fu"># Future Development</span></span>
<span id="cb14-738"><a href="#cb14-738"></a>As we look to the future, there are several areas where MedPipe3D can be expanded and improved to better serve the medical AI community. These include:</span>
<span id="cb14-739"><a href="#cb14-739"></a></span>
<span id="cb14-740"><a href="#cb14-740"></a><span class="fu">## Necessary Enhancements</span></span>
<span id="cb14-741"><a href="#cb14-741"></a></span>
<span id="cb14-742"><a href="#cb14-742"></a>Comprehensive Logging: Develop detailed logging mechanisms that capture a wide range of events, including system statuses, model performance metrics, and user activities, to facilitate debugging and system optimization. This is currently executed as a simple <span class="in">`println`</span> function.</span>
<span id="cb14-743"><a href="#cb14-743"></a></span>
<span id="cb14-744"><a href="#cb14-744"></a>TensorBoard Integration: Implement an interface for TensorBoard to allow users to visualize training dynamics in real time, providing insights into model behavior and performance trends.</span>
<span id="cb14-745"><a href="#cb14-745"></a></span>
<span id="cb14-746"><a href="#cb14-746"></a>Error and Warning Logs: Introduce advanced error and warning logging capabilities to alert users of potential issues before they affect the pipeline's performance, ensuring smoother operations and maintenance.</span>
<span id="cb14-747"><a href="#cb14-747"></a></span>
<span id="cb14-748"><a href="#cb14-748"></a>Automated Visualization: Integrate MedEye3D directly into MedPipe3D to enable automated visualization of outputs, such as segmentation masks or other relevant medical imaging features. This feature would provide users with real-time visual feedback on model performance and data quality.</span>
<span id="cb14-749"><a href="#cb14-749"></a>Code-Level Documentation: Due to needed changes in the fundamental structure of the pipeline in the final phase of the project, it is necessary to reevaluate all documentation.</span>
<span id="cb14-750"><a href="#cb14-750"></a></span>
<span id="cb14-751"><a href="#cb14-751"></a>Official JuliaHealth Documentation: Extend the documentation efforts to include official entries on juliahealth.org, providing a centralized and authoritative resource for users seeking to learn more about MedPipe3D and its capabilities with examples shown</span>
<span id="cb14-752"><a href="#cb14-752"></a></span>
<span id="cb14-753"><a href="#cb14-753"></a><span class="fu">## Potential Enhancements</span></span>
<span id="cb14-754"><a href="#cb14-754"></a>GPU support for interpolation will allow for significant acceleration of such functions as Scale transform, Simulate, Low-resolution transform, Elastic deformation transform, and Resampling spacing.</span>
<span id="cb14-755"><a href="#cb14-755"></a></span>
<span id="cb14-756"><a href="#cb14-756"></a>Add more reversible augmentations to test time.</span>
<span id="cb14-757"><a href="#cb14-757"></a></span>
<span id="cb14-758"><a href="#cb14-758"></a>Calculating the average of the edges of the picture: checking the type of photo and calculating more correctly on this basis</span>
<span id="cb14-759"><a href="#cb14-759"></a></span>
<span id="cb14-760"><a href="#cb14-760"></a>Elastic deformation transforms with the simulation of different tissue elasticities.</span>
<span id="cb14-761"><a href="#cb14-761"></a></span>
<span id="cb14-762"><a href="#cb14-762"></a><span class="fu"># Acknowledgments 🙇‍♂️</span></span>
<span id="cb14-763"><a href="#cb14-763"></a></span>
<span id="cb14-764"><a href="#cb14-764"></a>I would like to express my deepest gratitude to my mentor Dr. <span class="co">[</span><span class="ot">Jakub Mitura</span><span class="co">](https://www.linkedin.com/in/jakub-mitura-7b2013151/)</span> for his invaluable guidance and support throughout this project. His expertise and encouragement were instrumental in overcoming challenges and achieving project milestones.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, JuliaHealth.</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JuliaHealth/JuliaHealthBlog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/c/TheJuliaLanguage">
      <i class="bi bi-youtube" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml">
      <i class="bi bi-rss" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://julialang.org/slack/">
      <i class="bi bi-slack" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/julialanguage">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/edit/main/posts/JZubik-gsoc/GSoC_Jan_Zubik_MedPipe3D.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/JuliaHealth/JuliaHealthBlog/issues/new/choose" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>